# Стандарт кодирования XSLT для Codex

## Назначение документа

Этот документ описывает договорённости команды Codex по оформлению XSLT-стилей и дополняет их практическими рекомендациями. Цель стандарта — сделать трансформации понятными для новичков и устойчивыми при сопровождении, а также зафиксировать конкретные шаги по улучшению существующего кода.

## Основные принципы

1. **Читаемость важнее микропроизводительности.** Предпочитайте конструкции, которые легко понимают коллеги. Оптимизации выполняйте только после измерений и без ухудшения читаемости.
2. **Декларативный подход по умолчанию.** Используйте механизм сопоставления шаблонов (`match` + `xsl:apply-templates`) вместо императивных обходов, чтобы код оставался модульным.
3. **Тестируемость и модульность.** Разделяйте крупные стили на небольшие файлы, повторно используйте общие блоки через `xsl:import` / `xsl:include`, передавайте данные явно через параметры.
4. **Единообразие оформления.** Соблюдайте одинаковые соглашения по именованию, форматированию, организации директорий и комментариев, чтобы любой модуль выглядел узнаваемо.

## XPath и работа с шаблонами

### Рекомендуемые приёмы

- В шаблонах для обхода дочерних узлов используйте `<xsl:apply-templates>` и при необходимости атрибут `mode`.
- Сохраняйте XPath-выражения относительными к текущему контексту, избегая лидирующего `//` внутри шаблонов.
- Выносите длинные или повторяющиеся XPath в переменные с атрибутом `select` и говорящими именами.
- Для частых выборок по атрибутам или ключам создавайте `<xsl:key>` с комментариями о назначении.
- Предпочитайте буквальные элементы и атрибуты с фигурными скобками вместо `xsl:element`/`xsl:attribute`, когда имена известны заранее.
- Используйте «шаблон идентичности» (`xsl:copy` + `xsl:apply-templates`) как безопасную базу для копирования дерева и переопределяйте только отличающиеся узлы.

### Чего избегать

| Антипаттерн | Чем заменить | Обоснование |
| --- | --- | --- |
| `//` в начале XPath | Относительные пути или переменные с нужным контекстом | Ускоряет обработку и делает намерение очевидным.
| Длинные XPath в одну строку | Переменные, ключи, вспомогательные шаблоны | Повышает читабельность и переиспользование.
| Массовое применение `<xsl:for-each>` | `xsl:apply-templates` с режимами | Сохраняет декларативность и облегчает расширение.
| Статические элементы через `xsl:element`/`xsl:attribute` | Буквальные элементы | Сокращает объём кода.
| Повторяющиеся выражения | Вынос в переменные или функции | Исключает расхождения и улучшает производительность.
| Пустые конструкции `xsl:if` / `xsl:when` / `xsl:for-each` | Удаление таких блоков | Уменьшает шум.
| `xsl:variable` с вложенным `xsl:value-of` | Атрибут `select` у переменной | Делает объявление короче и быстрее.

## Именование и структура файлов

- Даём осмысленные имена шаблонам, режимам и переменным (`renderMainMenu`, `pageHeaderMode`). Однобуквенные имена допускаются только внутри коротких выражений-помощников.
- Повторно используемые шаблоны и функции выносим в отдельные файлы (`common/layout.xslt`, `common/formatting.xslt`) и подключаем через `xsl:include` или `xsl:import`.
- Каждый файл начинается с комментария, описывающего назначение, ожидаемый контекст и основные точки расширения.

## Комментарии и документация

- Комментарии объясняют «почему», а не «что». Фиксируйте бизнес-правила, нестандартные XPath, соглашения по параметрам и ключам.
- Для генерации комментариев в результирующем документе используйте `<xsl:comment>`, для внутренних пометок — `<!-- ... -->`.
- При добавлении нового ключа или режима документируйте его использование в начале файла.

## Тестирование и рефакторинг

- После добавления шаблона проводите рефакторинг: убирайте дубли, делайте XPath короче, разделяйте крупные конструкции на функции/шаблоны.
- Поддерживайте автоматические проверки (XSpec, unit-тесты проекта), добавляйте регрессионные тесты на обнаруженные дефекты.
- На ревью обращайте внимание на возможности перехода от pull-паттернов к push, укорачивайте XPath и выносите общие блоки в модули.

## Наблюдаемые проблемы и предложения по улучшению

- **SEO-модули активно используют абсолютные XPath.** В `engine/core/modules/seo/transformers/google_sitemap.xslt` шаблон корня запускает поиск `//component[@class='GoogleSitemap']`, а затем рекурсивно обращается к `recordset` через `xsl:for-each`. Рекомендуем перейти на явную передачу нужного компонента (`match="component[@class='GoogleSitemap']"` + `xsl:apply-templates` для дочерних `record`), а глобальные переменные `$LANG` и `$ID` заменить на параметры шаблонов. Это уберёт зависимость от абсолютного контекста и снизит стоимость трансформации.
- **Рекурсивный генератор карты сайта смешивает логику обхода и вывода.** В `google_sitemap.xslt` именованный шаблон `TREE_BUILDER` и вложенный `xsl:for-each` затрудняют тестирование и расширение (например, для поддержки `<lastmod>`). Предлагаем разнести обход и рендеринг: объявить шаблон `match="record" mode="sitemap"`, в котором формировать `<url>`, а вложенные коллекции обрабатывать через `xsl:apply-templates select="recordset/record" mode="sitemap"`.
- **Модуль `share` подмешивает глобальные коллекции без ключей.** В `engine/core/modules/share/transformers/single.xslt` переменная `$COMPONENTS` выбирает `//component[@name][@module]`, что приводит к полному обходу документа и усложняет предсказуемость вывода. Вместо этого следует либо принимать нужные компоненты параметрами, либо определить ключ `xsl:key name="component-by-name" match="component[@name][@module]" use="@name"` и вызывать `key('component-by-name', 'breadCrumbs', document)` из текущего контекста.
- **Зависимость от внешних переменных в модуле `auto`.** В `engine/core/modules/auto/transformers/test.xslt` встречаются выражения `//property[@name='title']` и использование `$COMPONENTS`, переменной, не объявленной в файле. Это создаёт скрытые связи с «глобальными» включаемыми шаблонами. Рекомендуем задокументировать обязательные параметры (например, `$page-properties`, `$components`) в начале файла и переключиться на относительные пути `property[@name='title']` внутри соответствующих шаблонов.
- **Закомментированный DOCTYPE и ручная склейка URL-ов.** Файл `share/transformers/single.xslt` содержит закомментированные строки DOCTYPE и формирует ссылки конкатенацией `xsl:value-of` внутри переменных. Стоит либо удалить неиспользуемые фрагменты, либо оформить их как параметры конфигурации. Для URL-ов лучше ввести вспомогательный шаблон или функцию, которая собирает путь из частей, чтобы избежать ошибок со слэшами и дублирования логики в разных компонентах.

## Дополнительные рекомендации

- **Контроль версий.** Добавьте в `.gitignore` артефакты сборки XSLT или кэш трансформаций, если они генерируются автоматически.
- **Профилирование.** Для тяжёлых трансформаций измеряйте производительность (например, Saxon `-TP`) и документируйте найденные узкие места и принятые решения.
- **Обработка ошибок.** Явно сигнализируйте о критических ситуациях через `<xsl:message terminate="yes">` и используйте осмысленные сообщения для логирования.
- **Обновление стандарта.** Пересматривайте документ при появлении новых практик. В шаблонах оставляйте TODO с ссылкой на соответствующий пункт стандарта, чтобы облегчить навигацию по техническому долгу.

