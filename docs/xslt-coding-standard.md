# Стандарт кодирования XSLT для Codex

## Назначение документа

Этот документ описывает договорённости команды Codex по оформлению XSLT-стилей. Цель стандарта — сделать трансформации понятными для новичков и устойчивыми при сопровождении. Рекомендации охватывают подходы к построению XPath, организации шаблонов, структуре файлов и оформлению HTML.

## Основные принципы

1. **Читаемость важнее микропроизводительности.** Предпочитайте конструкции, которые легко понимают коллеги. Оптимизации выполняйте только после измерений и без ухудшения читаемости.
2. **Декларативный подход по умолчанию.** Используйте механизм сопоставления шаблонов (`match` + `xsl:apply-templates`) вместо императивных обходов, чтобы код оставался модульным.
3. **Модульность и переиспользование.** Разделяйте крупные стили на небольшие файлы, подключайте общие блоки через `xsl:import` / `xsl:include`, передавайте данные явно через параметры.
4. **Единообразие оформления.** Соблюдайте одинаковые соглашения по именованию, форматированию, организации директорий и комментариев, чтобы любой модуль выглядел узнаваемо.

## XPath и работа с шаблонами

### Рекомендуемые приёмы

- В шаблонах для обхода дочерних узлов используйте `<xsl:apply-templates>` и при необходимости атрибут `mode`.
- Сохраняйте XPath-выражения относительными к текущему контексту, избегая лидирующего `//` внутри шаблонов.
- Выносите длинные или повторяющиеся XPath в переменные с атрибутом `select` и говорящими именами.
- Предпочитайте буквальные элементы и атрибуты с фигурными скобками вместо `xsl:element`/`xsl:attribute`, когда имена известны заранее.
- Для копирования веток оформляйте отдельные шаблоны, которые явно перечисляют, какие элементы и атрибуты переходят в вывод.

### Чего избегать

| Антипаттерн | Чем заменить | Обоснование |
| --- | --- | --- |
| `//` в начале XPath | Относительные пути или переменные с нужным контекстом | Ускоряет обработку и делает намерение очевидным. |
| Длинные XPath в одну строку | Переменные, вспомогательные шаблоны | Повышает читабельность и переиспользование. |
| Массовое применение `<xsl:for-each>` | `xsl:apply-templates` с режимами | Сохраняет декларативность и облегчает расширение. |
| Статические элементы через `xsl:element`/`xsl:attribute` | Буквальные элементы | Сокращает объём кода. |
| Повторяющиеся выражения | Вынос в переменные или функции | Исключает расхождения и улучшает производительность. |
| Пустые конструкции `xsl:if` / `xsl:when` / `xsl:for-each` | Удаление таких блоков | Уменьшает шум. |
| `xsl:variable` с вложенным `xsl:value-of` | Атрибут `select` у переменной | Делает объявление короче и быстрее. |
| `xsl:copy` / `xsl:copy-of` для массового переноса | Явные шаблоны с перечислением нужных узлов | Исключает скрытую логику и облегчает ревью. |
| `xsl:key` без доказанной необходимости | Фильтрация по текущему контексту или подготовленные переменные | Удерживает код простым для чтения. |

## Именование и структура файлов

- Даём осмысленные имена шаблонам, режимам и переменным (`renderMainMenu`, `pageHeaderMode`). Однобуквенные имена допускаются только внутри коротких выражений-помощников.
- Повторно используемые шаблоны и функции выносим в отдельные файлы (`common/layout.xslt`, `common/formatting.xslt`) и подключаем через `xsl:include` или `xsl:import`.
- Каждый файл начинается с комментария, описывающего назначение, ожидаемый контекст и основные точки расширения.

### Организация модулей и каталогов

- Все трансформеры ядра размещаются внутри `engine/core/modules/<module_name>/transformers/`.
- Верхний уровень каталога содержит правила для корневых веток: `document.xslt` отвечает за `/document`, `field.xslt` — за обработку `<field>`, сопутствующие файлы вроде `recordset.xslt` и `items.xslt` располагаются рядом, чтобы сохранить контекст.
- Компонентные шаблоны, которые работают с узлами `component[@name='...']` или `component[@class='...']`, помещаются в подкаталог `components/`. Имя файла пишется в `lowercase` без пробелов и отражает назначение (`components/textblock.xslt`, `components/sharebutton.xslt`).
- Если компонент имеет несколько вариантов отображения, оформляйте их в одном файле, разделяя логику через режимы (`mode`) или именованные шаблоны внутри `components/textblock.xslt`.
- Общие служебные правила (подготовка данных, фильтрация) держим в каталоге `common/` или `helpers/`, если они не завязаны на конкретную UI-библиотеку и переиспользуются в разных сборках.
- Устаревшие или неиспользуемые файлы (например, `media.xslt`) удаляются без замены. При необходимости функциональности создаётся современный компонент в `components/`.

### Чёткие запреты

- **Не выносите варианты одного компонента в отдельные файлы.** Все состояния (`compact`, `detailed`, `printable`) оформляются внутри одного XSLT через режимы или вспомогательные шаблоны.
- **Не размещайте трансформеры вне описанной структуры каталогов.** Файлы верхнего уровня отвечают за корневые ветки (`document.xslt`, `field.xslt`), а компоненты живут только в `components/` и тематических подпапках UI-стека.
- **Не возвращайте устаревшие подходы.** Не добавляйте обратно `media.xslt`, дублирующие Bootstrap-файлы и другие legacy-решения, вместо этого переносите логику в современные компоненты.
- **Не используйте `xsl:copy`, `xsl:copy-of` и `xsl:key`, когда задачу можно решить простыми шаблонами.** Эти инструкции затрудняют чтение и нарушают принятую архитектуру Codex.

### Специализация под UI-библиотеки

- Внутри каталога `transformers/` выделяем подкаталоги по UI-стекам. Для Bootstrap 5+ используем `transformers/bootstrap/`. Общие для всех стеков правила располагаются непосредственно в `transformers/`.
- Каждая библиотека наследует ту же структуру, что и корневой каталог: `bootstrap/document.xslt`, `bootstrap/components/textblock.xslt` и т. д. При добавлении новых библиотек (например, `transformers/mdbootstrap/`) переиспользуем общие файлы через `xsl:import`.
- Для модулей с большим количеством Bootstrap-шаблонов допускается дополнительный уровень группировки (`bootstrap/components/forms/`, `bootstrap/components/navigation/`).
- В `engine/core/modules/share/transformers/` точкой входа служит файл `include.xslt` в корне каталога. Он подключает общие правила (`document.xslt`, `field.xslt`) и нужный стек (`bootstrap/include.xslt`), который уже импортирует конкретные компоненты.

## Комментарии и документация

- Комментарии объясняют «почему», а не «что». Фиксируйте бизнес-правила, нестандартные XPath, соглашения по параметрам и режимам.
- Для генерации комментариев в результирующем документе используйте `<xsl:comment>`, для внутренних пометок — `<!-- ... -->`.
- При добавлении нового режима или параметра документируйте его использование в начале файла.

## Рефакторинг и код-ревью

- После добавления шаблона проводите рефакторинг: убирайте дубли, делайте XPath короче, разделяйте крупные конструкции на функции/шаблоны.
- На ревью обращайте внимание на возможности перехода от pull-паттернов к push, укорачивайте XPath и выносите общие блоки в модули.
- Перед коммитом проверяйте, что все подключаемые файлы задокументированы, а новые параметры явно передаются в шаблоны.

## HTML и UI-оформление

- Генерируемая разметка должна соответствовать Bootstrap 5+ (классы контейнеров, сетки, компонентов). Проверяйте совместимость с актуальной документацией Bootstrap.
- При добавлении новых компонентов учитывайте будущую интеграцию MDBootstrap: используйте семантичные классы и избегайте жёстко зашитых цветовых схем, чтобы проще подключать дополнительные CSS/JS.
- Избегайте устаревших классов Bootstrap 3/4 и inline-стилей, если есть готовые утилиты в Bootstrap 5.

## Дополнительные рекомендации

- **Контроль версий.** Добавьте в `.gitignore` артефакты сборки XSLT или кэш трансформаций, если они генерируются автоматически.
- **Профилирование.** Для тяжёлых трансформаций измеряйте производительность (например, Saxon `-TP`) и документируйте найденные узкие места и принятые решения.
- **Обработка ошибок.** Явно сигнализируйте о критических ситуациях через `<xsl:message terminate="yes">` и используйте осмысленные сообщения для логирования.
- **Обновление стандарта.** Пересматривайте документ при появлении новых практик. В шаблонах оставляйте TODO с ссылкой на соответствующий пункт стандарта, чтобы облегчить навигацию по техническому долгу.
