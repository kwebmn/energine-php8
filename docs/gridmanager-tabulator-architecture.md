# GridManager â†’ Tabulator Architecture

## Tabulator version and loading strategy
- **Distribution**: Tabulator 5.5.2 (UMD bundle, stored in `scripts/lib/tabulator/`) to keep compatibility with legacy ScriptLoader and avoid a build step. The directory ships `tabulator.min.js`, `tabulator.min.css`, and the Bootstrap 5 theme alongside the upstream MIT license.
- **Loading**: register `lib/tabulator/tabulator.min` in the existing `ScriptLoader.load(...)` chain so that GridManager waits for the library before instantiation. CSS assets load via `Energine.loadCSS('scripts/lib/tabulator/...')` during module initialization, ensuring the styles are present even when the script executes outside the legacy loader flow.
- **Styling**: keep Bootstrap card markup created by XSLT; mount the Tabulator instance into the `div[data-role="grid-table"]` container inside the grid body. Apply the Bootstrap theme (`tabulator_bootstrap5.min.css`) to blend with existing Energine classes while relying on the `.tabulator` namespace to avoid global style conflicts.

## Mapping legacy metadata to Tabulator options
| Legacy payload | Target Tabulator option | Notes |
| --- | --- | --- |
| `meta[field].title` | `columns[].title` | Preserve localization and HTML; apply escaping consistent with current Grid.iterateFields. |
| `meta[field].name` | `columns[].field` | Use as the Tabulator field key; identical to the property names in `data` records. |
| `meta[field].type` | `columns[].formatter`/`columns[].hozAlign` | Map Energine field types to Tabulator formatters (checkbox/file/icon/etc.). Provide a lookup helper mirroring `Grid.iterateFields`. |
| `meta[field].visible` | `columns[].visible` | Respect hidden columns used for row keys or system data. |
| `meta[field].sort` | `initialSort` / `column.defaultSort` | Translate persisted sort order when instantiating the grid. |
| `meta[field].key` | `index` / `rowKey` | Tabulator uses `index` or `rowFormatter` to flag the primary key; store the field name to support selection and CRUD actions. |
| `data` array | `data` (initial load) | Preload local data for the first render before asynchronous refresh. |
| `pager.current` | `paginationInitialPage` | Start Tabulator pagination from the server-provided current page. |
| `pager.count` | `paginationSize`/`paginationSizeSelector` | Derive available page sizes; keep summary text in the footer via custom renderer. |
| `pager.records` | Custom footer renderer | Inject the string into the legacy footer DOM to preserve UX. |
| Request URL from `GridManager.buildRequestURL()` | `ajaxURL` | Keep the existing URL generation logic intact. |
| POST body from `GridManager.buildRequestPostBody()` | `ajaxParams` | Pass sorting/filtering/language parameters. Reuse legacy helper to keep compatibility with backend contracts. |
| `mode`, `breadcrumbs`, other extras | `ajaxResponse` hook | Store in GridManager state and re-render auxiliary widgets (breadcrumbs, toolbars). |

Set Tabulator `ajaxConfig` to `method: 'post'` so that the server contract does not change.

## Component responsibilities in the new architecture
- **GridManager (facade)**
  - Owns lifecycle: reads DOM generated by XSLT, resolves toolbar/filter/pagination containers, instantiates the Tabulator adapter.
  - Keeps legacy public API (`view/add/edit/...`) and delegates data operations to the Tabulator instance.
  - Bridges custom UI elements (filter form, toolbar buttons, breadcrumbs) with Tabulator state and server responses.
  - Continues to expose events (`onSelect`, `onDoubleClick`, `onSortChange`) while internally subscribing to Tabulator events.

- **TabulatorAdapter (new internal helper)**
  - Wraps `new Tabulator(...)`, applying column definitions built from `meta` and `Grid.iterateFields` logic.
  - Handles remote pagination (`pagination: true`, `paginationMode: 'remote'`) so that `loadPage` simply updates `ajaxParams.page` and calls `table.setPage(page)`.
  - Stores the key field name to maintain legacy selection APIs (`getSelectedRecordKey`, `selectItem`, etc.).
  - Exposes a minimal surface (`setData(meta, data, pager)`, `reload(options)`, `getSelectedRow()`) consumed by GridManager.

- **Filter module**
  - Remains mostly unchanged but writes its state into `GridManager.buildRequestPostBody()` so Tabulator receives up-to-date filters through `ajaxParams` before each request (`ajaxRequesting`).
  - Triggers `GridManager.reload()` to call `table.setData()` with the recalculated params.

- **Pagination UI (PageList)**
  - Reuse existing DOM-based paginator by listening to Tabulator `pageLoaded` event and, conversely, calling `table.setPage(n)` when a user uses the legacy paginator. Alternatively, hide the native Tabulator pagination controls and continue rendering the Energine paginator in the card footer.

## Event bridge
| Tabulator event | Legacy hook | Behaviour |
| --- | --- | --- |
| `ajaxRequesting(url, params)` | `GridManager.buildRequestPostBody`, `showLoader` | Mutate params with filter/sort/page data, display the global loader, fire custom `beforeLoad` event if needed. |
| `ajaxResponse(url, params, response)` | `GridManager.processServerResponse` | Validate payload, update breadcrumbs/mode, rebuild columns if `meta` changed, feed `PageList`. Hide loader on success. |
| `ajaxError` | `GridManager.processServerError` | Route errors through existing notifier and restore UI state. |
| `dataSorting(sorters)` | `Grid.onChangeSort`/`GridManager.onSortChange` | Translate Tabulator sorter descriptors back into Energine format, update stored sort state, and trigger a remote reload. |
| `dataFiltered(filters, rows)` | Filter toolbar state | Synchronize `Filter` UI (e.g., disable reset button when empty) and keep `GridManager` aware of active filters. |
| `rowSelectionChanged(data, rows)` | `Grid.selectItem`/`onSelect` | Persist currently selected record, update toolbar button states, fire legacy callbacks. |
| `rowDblClick(e, row)` | `GridManager.onDoubleClick` | Execute the default double-click action (edit/view). |
| `pageLoaded(pageno)` | `PageList.selectPageByNum` | Keep the footer paginator aligned with Tabulator's remote pagination. |

## Preserved public API surface
GridManager must retain the methods relied upon by Energine modules, even if internally they redirect to Tabulator helpers:
- **Lifecycle & data**: `reload`, `loadPage`, `buildRequestURL`, `buildRequestPostBody`, `processServerResponse`, `processServerError`, `processAfterCloseAction`, `setMetadata`, `setData`, `clear`.
- **Selection & navigation**: `selectItem`, `deselectItem`, `getSelectedItem`, `getSelectedRecord`, `getSelectedRecordKey`, `setMvElementId`, `getMvElementId`, `clearMvElementId`.
- **Sorting**: `sortChange`, `onSortChange` (delegating to Tabulator `setSort` / `getSorters`).
- **User actions**: `view`, `add`, `edit`, `editPrev`, `editNext`, `del`, `use`, `close`, `move`, `moveFirst`, `moveLast`, `moveAbove`, `moveBelow`, `moveTo`, `up`, `down`, `print`, `csv`.
- **Integration points**: `attachToolbar`, `onTabChange`, `onSelect`, `onDoubleClick`.

Any new helpers (e.g., `TabulatorAdapter`) stay private to keep the public API stable while allowing the implementation to adopt Tabulator internals.

## Data loading flow
1. `GridManager.reload()` builds URL/params and calls `tabulator.setData()`; Tabulator fires `ajaxRequesting`.
2. During `ajaxRequesting`, GridManager injects filter/sort/page params, shows the loader, and keeps `PageList` disabled.
3. The server responds with `{ meta, data, pager, ... }`; `ajaxResponse` hands it to `GridManager.processServerResponse`, which updates the adapter (`setColumns`, `replaceData`), refreshes the paginator, and restores toolbar availability.
4. Tabulator renders rows; `rowSelectionChanged` keeps selection state, and `rowDblClick` triggers legacy double-click actions.

This architecture keeps the external behaviour of GridManager intact while delegating rendering, virtual DOM, and remote pagination to Tabulator.
