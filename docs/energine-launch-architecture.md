# Архитектура запуска Energine и разделение поведения

## 1. Общие положения

Документ описывает требования к переработке клиентской части Energine с целью полного разделения структуры HTML и поведенческой логики, унификации конфигурации через `data-*` атрибуты и перехода на модульную загрузку ES6. Техническое задание распространяется на шаблоны XSLT, клиентские JavaScript-модули и HTML-разметку, генерируемую административным интерфейсом.

### 1.1. Ограничения и неизменяемые части

- Текущие `*.component.xml` **не** перерабатываются и остаются единственным источником данных для XSLT. Миграция поведения выполняется только за счёт обновления XSLT и JavaScript-модулей.
- Весь объём работ выполняется внутри существующих файлов. Создание новых модулей, шаблонов или конфигураций допускается только после отдельного согласования.

### 1.2. Основные цели оптимизации

- Уменьшение размера обязательного JavaScript-бандла достигается за счёт удаления и декомпозиции неиспользуемого кода, а не за счёт дополнительной минификации (Vite уже выполняет сжатие).
- Чёткое разделение базового ядра Energine и опциональных подсистем (UI, сетевые утилиты, тулбары), чтобы tree shaking и условные импорты могли исключать ненужные ветки кода.
- Перенос генерации справочников (например, `PageToolbar` и других административных панелей) в XSLT, чтобы JavaScript отвечал исключительно за поведение и работу со стейтом.

## 2. Требования к разметке

1. **Запрет на inline-скрипты**
   - В XSLT и других шаблонах запрещено использовать теги `<script>` с инлайновым кодом и любые JavaScript-обработчики в атрибутах элементов (`onclick`, `onchange`, `onload` и т.д.).
   - Все обработчики событий описываются во внешних JS-модулях и навешиваются программно.

2. **Структура без поведения**
   - Разметка должна формировать только структурный и семантический HTML.
   - Для взаимодействия компонентов применяются `data-*` атрибуты, описывающие идентификаторы действий, параметры и состояния.

3. **Размещение сценариев**
   - Подключение базового модуля `Energine.js` выполняется тегом `<script type="module" src="/path/to/Energine.js"></script>` перед `</body>` либо сразу после завершающего содержимого, чтобы гарантировать готовность DOM.
   - Дополнительные модули подключаются аналогично как ES6-модули либо входят в собранный бандл.

## 3. Конфигурация через `data-*`

1. **Основной контейнер конфигурации**
   - Для страниц, требующих инициализации Energine, на элемент `<body>` добавляется атрибут `data-energine-run="1"`.
   - Дополнительные параметры (режим отладки, базовый путь, язык локализации и др.) передаются только через `data-*` атрибуты либо на `<body>`, либо на тег `<script src="Energine.js">`.

2. **Чтение конфигурации**
   - Метод `Energine.readConfigFromScriptDataset()` должен использоваться для формирования объекта конфигурации из `dataset` соответствующего тега `<script>`.
   - Полученный объект передается в `Energine.boot(config)`.

3. **Минимизация серверной логики**
   - XSLT-шаблоны формируют только значения `data-*` атрибутов. Никаких JS-функций или выражений в шаблонах не допускается, как и прокидывание данных через глобальные переменные, JSON-блоки или inline-скрипты.

## 4. Инициализация клиентской части

1. **Точка входа**
   - После загрузки DOM (`DOMContentLoaded`) либо при выполнении скрипта, размещенного в конце `body`, модуль `Energine.js` проверяет наличие флага `data-energine-run`.
   - При наличии флага выполняется `Energine.boot(config)` с конфигурацией, прочитанной из `data-*` атрибутов.
   - При отсутствии флага инициализация пропускается, что позволяет использовать общие шаблоны без избыточного кода.
   - Автоматический запуск переносится в сам модуль: `Energine.js` определяет `<script type="module">`, из которого он был загружен, считывает его `dataset` через `readConfigFromScriptDataset()` и вызывает `bootEnergine()` без участия inline-кода. Текущий bootstrap в `document.xslt`, импортирующий `bootEnergine` и вручную создающий рантайм, подлежит удалению после переноса логики внутрь модуля.【F:engine/core/modules/share/transformers/bootstrap/document.xslt†L205-L260】【F:engine/core/modules/share/scripts/Energine.js†L268-L312】

2. **Поддержка режимов**
   - В режиме разработки допускается подключение исходных ES6-модулей без предварительной сборки.
   - В продуктивном режиме используется собранный минифицированный бандл, но интерфейс инициализации остается неизменным.

## 5. Тулбар и элементы управления

 1. **Генерация разметки**
    - Тулбар и кнопки генерируются XSLT как чистый HTML. Простейшая структура:
      ```html
      <div class="toolbar" data-toolbar="main">
        <button type="button" data-action="add" data-confirm="Добавить запись?">
          <i class="fa fa-plus"></i>
          <span>Добавить</span>
        </button>
      </div>
      ```
    - Все параметры поведения описываются через `data-action`, `data-confirm`, `data-disabled`, `data-i18n` и аналогичные атрибуты.
    - Справочники и административные панели (`PageToolbar`, фильтры, списки действий) возвращаются XSLT-шаблонами; JavaScript не должен заниматься их отрисовкой через DOM API или шаблонизацию.

    **Наследуемые соглашения PageToolbar**

    - Текущая система рендерит верхнюю панель (`.e-topframe`) с контейнером `<div class="btn-toolbar ..." data-toolbar="main_toolbar">`, в котором каждая кнопка имеет идентификатор вида `main_toolbar{controlId}` и атрибут `data-control-id`. Эти значения участвуют в логике `PageToolbar.js` и должны сохраняться XSLT-шаблоном, но перемещаются в `data-*`.
    - Для кнопок используется классическая Bootstrap-структура (`btn btn-sm ...`), иконки FontAwesome (`<i class="fa ..."></i>`) и вспомогательные подписи `<span class="toolbar-control-label">`. XSLT обязан выпускать тот же набор классов и элементов, чтобы не нарушить внешний вид до момента рефакторинга стилей.
    - Специальные типы элементов (например, `type="switcher"` для режимов) транслируются в явные `data-type="switcher"`, чтобы JS мог определить поведение без чтения нестандартных HTML-атрибутов. Дополнительно сохраняется ARIA (`aria-pressed`, `aria-controls`) и `data-bs-*` для интеграции с Bootstrap.
    - Рядом с основной панелью располагается offcanvas-блок (`#main_toolbar-sidebar`), содержащий `<iframe>` с административной панелью. Его триггеры (кнопка бургер-меню) должны описываться XSLT через `data-bs-toggle="offcanvas"`/`data-bs-target` и соответствующие ID, а JS лишь инициализирует/слушает события Bootstrap.
- Конфигурация, которая раньше прокидывалась в `new PageToolbar([...])`, теперь раскладывается по атомарным `data-*` атрибутам (`data-control-id`, `data-action`, `data-state` и т.д.) на корневом контейнере и его дочерних элементах. Сериализация в JSON, скрытые `<script>` или глобальные переменные запрещена.
- Все кнопки и управляющие элементы, формируемые `toolbar.xslt`, включая вспомогательные тулбары и плагины (`Toolbar.js`, `Filters`, «редактировать», «предпросмотр» и т.д.), переносят конфигурацию в `data-*` атрибуты по тем же правилам. JavaScript инициализирует их, считывая `dataset`, без необходимости собирать конфигурацию в XSLT. Исключения допускаются только для уже существующих Bootstrap-атрибутов (`data-bs-*`) и ARIA.

2. **Разделение ответственности**
    - XSLT формирует статичную структуру и контент, включая упорядочивание элементов, иконки, текст и подсказки.
    - JavaScript ограничивается навешиванием поведения, чтением `data-*` атрибутов и управлением состоянием без динамического создания элементов при инициализации.

3. **Привязка поведения**
   - Класс `Toolbar` (либо специализированные модули) ищет элементы по селекторам `[data-action]` и назначает обработчики через `addEventListener`.
   - Логика действий реализуется в JavaScript, используя значения атрибутов. Пример:
     ```javascript
      document.addEventListener('DOMContentLoaded', () => {
        document.querySelectorAll('[data-action]').forEach((button) => {
          button.addEventListener('click', () => Toolbar.handleAction(button));
        });
      });
     ```

 4. **Расширяемость**
   - Новые типы кнопок или действий добавляются путем расширения модулей JS без изменения XSLT.
   - XSLT отвечает за структуру, визуальное оформление, локализацию подписей и иконок.

### 5.1. Декларативный `PageToolbar`

- Создание экземпляра `PageToolbar` из inline-скрипта в `document.xslt` ликвидируется. Вся конфигурация (`componentPath`, `documentId`, `toolbarName`, набор контролов, свойства сайдбара) распределяется по `data-*` атрибутам корневого контейнера и дочерних элементов. Модуль считывает их при инициализации вместо JSON-объекта, который сейчас собирается в шаблоне.【F:engine/core/modules/share/transformers/bootstrap/document.xslt†L224-L244】
- XSLT генерирует `<div data-page-toolbar="main" ...>` (или аналогичный элемент) и вложенные кнопки/панели с атрибутами `data-control-id`, `data-action`, `data-role`, `data-offcanvas-target`, `data-sidebar-url`, чтобы `PageToolbar` мог построить поведение на стороне клиента без реконструкции структуры.
- `Energine.js` при загрузке определяет наличие `[data-page-toolbar]`, формирует объект настроек из `dataset` и передает его в `PageToolbar` (или регистрирует задачу в очереди). Это исключает зависимость от глобального массива `componentToolbars` и от `componentToolbars[...] = new Toolbar(...)`, генерируемого сейчас XSLT.【F:engine/core/modules/share/transformers/bootstrap/toolbar.xslt†L178-L214】

### 5.2. Макет тулбара и сайдбара

- Текущий `PageToolbar.js` динамически создаёт весь layout (topframe, контейнеры кнопок, offcanvas-сайдбар, бургер-кнопку с логотипом). Эта логика переносится в XSLT, чтобы HTML с самого начала соответствовал целевому виду интерфейса и был доступен без JavaScript.【F:engine/core/modules/share/scripts/PageToolbar.js†L101-L212】
- XSLT формирует:
  - верхнюю панель с контейнером кнопок и строкой действий (включая разделение на «primary» и «secondary» блоки),
  - бургер-кнопку управления сайдбаром (иконка вместо логотипа; кнопка управляет `data-bs-target` offcanvas-панели),
  - правый блок статуса/переключателей (например, окружения, выбора режима),
  - offcanvas-панель с `<iframe>` редактора дерева разделов, классами Bootstrap и атрибутами `aria`.
- Отдельные элементы (бургер, кнопки окружения, счетчики) получают `data-*` атрибуты состояния (`data-sidebar-state`, `data-environment`, `data-view-mode`), чтобы `PageToolbar` только подписывался на события и изменял классы без перерисовки DOM.
- Сайдбар и верхняя панель должны повторять композицию, показанную в референсном интерфейсе: фиксированная верхняя навигация с кнопками действий и collapsible сайдбар, который можно раскрыть/скрыть той же бургер-кнопкой. Дизайн (цвета, отступы, иконки) может отличаться, но сетка и взаимодействия обязаны соответствовать описанной структуре.

### 5.3. Инициализация и связка с `Energine.js`

- После переноса разметки XSLT добавляет на `<body>` и/или корневые блоки `data-energine-run`, `data-page-toolbar`, `data-toolbar-scope` и другие параметры, которые считывает модуль `Energine.js` при автозапуске.
- `PageToolbar` при создании должен обходить уже существующую разметку (например, `document.querySelectorAll('[data-toolbar="main"] [data-action]')`) и назначать обработчики. Никакого программного `document.createElement` на этапе инициализации, кроме как для динамических узлов (например, всплывающих подсказок), не допускается.
- Состояние сайдбара (открыт/закрыт) хранится в `dataset` (`data-sidebar-expanded`) и синхронизируется с cookie через существующие методы класса, чтобы восстановление при перезагрузке не требовало перестраивания DOM вручную.【F:engine/core/modules/share/scripts/PageToolbar.js†L154-L212】
- Локализационные строки продолжают передаваться из PHP как JSON (один общий объект переводов), поскольку XSLT не управляет текстами интерфейса. `Energine.js` читает JSON-блок переводов, объединяет его с данными `data-*` и передает в модули тулбаров.

## 6. Требования к совместимости

1. **Поддерживаемые браузеры**
   - Минимальные требования — современные версии браузеров с поддержкой ES6-модулей.
   - Для старых браузеров (если требуется) предоставляется сборка-бандл, совместимая с ES5, подключаемая условно.

2. **Совместимость с существующим кодом**
   - Постепенная миграция: допускается временное сосуществование старых и новых шаблонов при условии, что в новых шаблонах соблюдается запрет на inline JS.
   - Депрецированный код собирается в отдельные задачи на удаление.

## 7. Тестирование и приемка

1. **Проверки**
   - Визуальная проверка административных интерфейсов на корректность отображения и работы тулбаров.
   - Проверка отсутствия inline-скриптов в генерируемом HTML.
   - Валидация передачи конфигурации через `data-*` и корректной инициализации `Energine.boot()`.

2. **Документация**
   - Обновление разработческой документации с примерами новых шаблонов и модулей.
   - Подготовка руководства по миграции для команд, отвечающих за XSLT и JS.

## 8. Критерии завершения

- Все административные страницы используют новую схему инициализации без inline JS.
- Конфигурационные параметры полностью передаются через `data-*` атрибуты.
- Тулбар и элементы управления реализованы через семантическую разметку и подключаемое поведение.
- В режиме разработки проект запускается без сборки через подключение ES6-модулей.
- Документация обновлена и доступна команде разработки.

## 9. Анализ текущего состояния

### 9.1. Energine.js

- Базовый модуль насчитывает 882 строки и объединяет в одном файле конфигурацию, мост между `window` и рантаймом, сетевые
  помощники, Bootstrap-модальные окна, тосты и оверлеи загрузчика.【F:engine/core/modules/share/scripts/Energine.js†L1-L882】
- Текущая реализация `initBridge`/`__energineBridge` удерживает отложенные задания и конфигурацию, усложняя загрузку и увеличивая
  объем кода, который можно заменить детерминированным порядком инициализации.【F:engine/core/modules/share/scripts/Energine.js†L37-L200】
- Функция `request` сочетает несколько код-путей (form-urlencoded, JSON, GET) и вызывает `alert`, что препятствует повторному
  использованию и усложняет перенос на промисы/`fetch`-утилиты.【F:engine/core/modules/share/scripts/Energine.js†L305-L393】
- UI-хелперы (`confirmBox`, `alertBox`, `noticeBox`, `showLoader`) встраивают Bootstrap- и FontAwesome-разметку, что увеличивает
  минимальный размер ядра даже для страниц без админки.【F:engine/core/modules/share/scripts/Energine.js†L425-L838】
- Минификация выполняется средствами Vite, однако отсутствие модульного деления приводит к включению в бандл вспомогательных
  функций, которые не используются на большинстве страниц и лишь сжимаются вместо исключения.
- Внутри файла присутствуют устаревшие заглушки (`singleMode`, `legacyToolbar`), которые больше не вызываются и лишь увеличивают
  объём бандла.【F:engine/core/modules/share/scripts/Energine.js†L520-L750】

**Требуемые действия**

1. Выделить ядро (чтение `dataset`, очередь задач, API конфигурации) в отдельный модуль и подключать UI/сетевые модули по
   мере необходимости, уменьшая обязательный бандл.【F:engine/core/modules/share/scripts/Energine.js†L37-L393】
2. Переписать сетевой слой на отдельный модуль, возвращающий промисы/`async`-результаты без побочных эффектов UI, чтобы его можно
   было переиспользовать в разных пакетах.【F:engine/core/modules/share/scripts/Energine.js†L305-L393】
3. Вынести Bootstrap-зависимые компоненты и оверлеи в модуль админ-интерфейса, оставив ядру только текстовые фолбэки.
   【F:engine/core/modules/share/scripts/Energine.js†L425-L838】
4. Сохранить тонкий адаптер `attachToWindow` как обратную совместимость и планомерно отказаться от глобального моста после
   миграции страниц.【F:engine/core/modules/share/scripts/Energine.js†L790-L838】
5. Провести инвентаризацию экспортируемых функций (`queueTask`, `registerToolbar`, `setStyles` и т.д.) и удалить сценарии,
   которые не используются в XSLT или модулях, чтобы Vite мог исключать их из итогового бандла на этапе tree shaking.
6. Собрать карту зависимостей и зафиксировать, какие подсистемы (тулбары, модальные окна, загрузчик) реально требуются в
   продуктиве; по умолчанию они не входят в ядро и подключаются только из страниц, где присутствуют соответствующие `data-*`
   атрибуты.

### 9.2. `document.xslt`

- Шаблон всегда подключает вендорные бандлы и Energine-модуль, даже если страница не требует административного функционала,
  что увеличивает ненужный трафик для публичных страниц.【F:engine/core/modules/share/transformers/bootstrap/document.xslt†L162-L203】
- Внутри шаблона остаются встроенные `<script type="module">`, которые импортируют `bootEnergine`, управляют тулбарами и
  объектами, тем самым нарушая принцип «структура без поведения».【F:engine/core/modules/share/transformers/bootstrap/document.xslt†L177-L260】
- Комментарии с устаревшим inline-JS (например, `window.singleMode`) создают шум при ревью и должны быть удалены вместе с
  переносом логики в модули.【F:engine/core/modules/share/transformers/bootstrap/document.xslt†L137-L144】

**Требуемые действия**

1. Добавить условия для подключения скриптов и стилей только на страницах с `data-energine-run="1"` и необходимыми
   компонентами.【F:engine/core/modules/share/transformers/bootstrap/document.xslt†L162-L205】
2. Перенести запуск `bootEnergine`, регистрацию тулбаров и работу с `componentToolbars` в модуль `Energine.js`/отдельные
   контроллеры, оставив XSLT только генерацию `data-*` атрибутов.【F:engine/core/modules/share/transformers/bootstrap/document.xslt†L205-L260】
3. Удалить устаревшие комментарии и подготовить чистую разметку для отслеживания внедрения unobtrusive JS.

### 9.3. `toolbar.xslt`

- Кнопки тулбара до сих пор генерируют `onclick`-атрибуты, напрямую ссылающиеся на методы JS, что препятствует декларативной
  привязке поведения.【F:engine/core/modules/share/transformers/bootstrap/toolbar.xslt†L55-L166】
- Шаблон содержит встроенный `<script type="module">`, который импортирует `queueTask` и `Toolbar`, а затем программно
  заполняет тулбары, что нарушает требование об отсутствии inline JS.【F:engine/core/modules/share/transformers/bootstrap/toolbar.xslt†L178-L219】
- Оставшиеся комментарии с `setStyles` указывают на зависимость от ручных расчётов высоты, которую необходимо заменить
  CSS-классами и JS-модулями вне XSLT.【F:engine/core/modules/share/transformers/bootstrap/toolbar.xslt†L192-L204】

**Требуемые действия**

1. Заменить `onclick` на `data-action`, `data-confirm` и дополнительные атрибуты состояния, чтобы JS-модули могли навешивать
   обработчики через `addEventListener`.
2. Переместить инициализацию тулбаров в модуль (например, `ToolbarController`), который запускается из Energine после чтения
   конфигурации страницы.【F:engine/core/modules/share/transformers/bootstrap/toolbar.xslt†L178-L219】
3. Переработать расчёт размеров с помощью CSS-макетов и служебных классов вместо встроенных комментариев.

### 9.4. HTML, генерируемый текущей административной панелью

- Верхняя панель (`.e-topframe`) содержит как основной тулбар (`.btn-toolbar[data-toolbar]`), так и offcanvas-сайдбар (`#main_toolbar-sidebar`) с `<iframe>` административной панели. Идентификаторы вида `main_toolbar*` и `data-control-id` используются для связывания кнопок с JS-логикой `PageToolbar`.
- Каждая кнопка одновременно содержит `data-bs-toggle`, `aria-*` и пользовательские атрибуты (`type="switcher"`, `data-control-id`). Существующая реализация сочетает Bootstrap и пользовательские состояния, поэтому при миграции XSLT должен выпускать весь набор атрибутов, а JS — нормализовать их в единый объект состояния.
- JSON-конфигурация, передаваемая в `new PageToolbar([...])`, дублирует информацию, уже присутствующую в DOM (идентификаторы, заголовки, иконки). При переносе на XSLT необходимо устранить дублирование: данные выводятся единожды в HTML, а модуль `PageToolbar` читает их из `dataset` (`data-*`).
- Подключение модулей сейчас выполняется inline-скриптом, который импортирует `Energine.js`, создаёт рантайм и регистрирует `PageToolbar`. Этот код переносится в модульную загрузку: XSLT оставляет только `<script type="module" src=".../Energine.js" data-*="...">`, а остальная логика инициируется из модуля после `DOMContentLoaded`.

**Требуемые действия**

1. Сгенерировать offcanvas-разметку и кнопки в XSLT, сохранив существующие классы и идентификаторы, но заменив нестандартные атрибуты (`type="switcher"`) на `data-*`.
2. Переместить данные, которые сейчас передаются конструктору `PageToolbar`, в атомарные `data-*` атрибуты самого тулбара и его элементов управления, чтобы модуль мог прочитать описание действий без inline-JS.
3. Настроить модуль `PageToolbar` на чтение DOM-конфигурации, включая ARIA-атрибуты, Bootstrap-триггеры и информацию о сайдбаре, вместо ожидания глобальных массивов или `componentToolbars`.

### 9.5. Конфигурационные XML компонентов

- Текущие определения (`*.component.xml`) остаются неизменными и используются как источник данных для XSLT; модернизация
  поведения выполняется на уровне шаблонов и клиентских модулей.
- При разработке модульных контроллеров необходимо учитывать существующую схему `onclick`/`loader="classic"`, обеспечив
  совместимость путём интерпретации этих настроек в JS без модификации самих XML-файлов.

**Требуемые действия**

1. Сохранить схемы `*.component.xml` без изменений, документировав точки расширения для чтения их параметров из JS.
2. Реализовать слой преобразования, который конвертирует существующие параметры (`onclick`, `loader`) в `data-*` атрибуты при
   генерации разметки, чтобы переход к unobtrusive JS не требовал переписывания конфигураций.
3. Обеспечить тесты, подтверждающие, что новые контроллеры корректно работают с существующими XML-настройками без их правки.

## 10. План поэтапного рефакторинга

1. **Оптимизировать Energine.js**: выделить конфигурационный/очередной функционал в отдельный модуль, удалить неиспользуемые
   помощники и подключать UI/сетевые части по требованию (lazy-load или условные импорты), чтобы уменьшить объём кода, который
   попадает в бандл ещё до минификации Vite. При ревизии каждый экспорт проверяется на фактическое использование; мёртвый код
   удаляется, а избыточные зависимости заменяются точечными импортами.【F:engine/core/modules/share/scripts/Energine.js†L37-L838】
2. **Очистить шаблоны**: обновить `document.xslt` и `toolbar.xslt`, чтобы они генерировали только разметку с `data-*` и не
   содержали `<script>`, перенести логику загрузки тулбаров в JS-модули. При этом любая информация, приходящая из
   `*.component.xml`, транслируется в `data-*` без изменений исходных XML.【F:engine/core/modules/share/transformers/bootstrap/document.xslt†L162-L260】【F:engine/core/modules/share/transformers/bootstrap/toolbar.xslt†L55-L219】
3. **Ввести модульные контроллеры**: реализовать тонкие JS-адаптеры внутри существующих файлов, которые читают конфигурацию из
   `*.component.xml`, не изменяя их схему, и обеспечивают работу тулбаров и форм через `data-*` атрибуты. Новые контроллеры
   подключаются через условные импорты, чтобы страницы без тулбаров не тянули лишний код.
4. **Ввести контроль качества**: добавить статический анализ (например, линтер XSLT/HTML) и тесты, проверяющие, что в рендере
   нет `onclick` и что ядро Energine остаётся модульным после дальнейших правок. Дополнительно настроить отчёты о размере
   бандлов, чтобы фиксировать эффект от удаления кода, а не от минификации.
