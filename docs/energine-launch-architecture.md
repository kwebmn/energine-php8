# Архитектура запуска Energine и разделение поведения

## 1. Общие положения

Документ описывает требования к переработке клиентской части Energine с целью полного разделения структуры HTML и поведенческой логики, унификации конфигурации через `data-*` атрибуты и перехода на модульную загрузку ES6. Техническое задание распространяется на шаблоны XSLT, клиентские JavaScript-модули и HTML-разметку, генерируемую административным интерфейсом.

### 1.1. Ограничения и неизменяемые части

- Текущие `*.component.xml` **не** перерабатываются и остаются единственным источником данных для XSLT. Миграция поведения выполняется только за счёт обновления XSLT и JavaScript-модулей.
- Весь объём работ выполняется внутри существующих файлов. Создание новых модулей, шаблонов или конфигураций допускается только после отдельного согласования.

### 1.2. Основные цели оптимизации

- Уменьшение размера обязательного JavaScript-бандла достигается за счёт удаления и декомпозиции неиспользуемого кода, а не за счёт дополнительной минификации (Vite уже выполняет сжатие).
- Чёткое разделение базового ядра Energine и опциональных подсистем (UI, сетевые утилиты, тулбары), чтобы tree shaking и условные импорты могли исключать ненужные ветки кода.

## 2. Требования к разметке

1. **Запрет на inline-скрипты**
   - В XSLT и других шаблонах запрещено использовать теги `<script>` с инлайновым кодом и любые JavaScript-обработчики в атрибутах элементов (`onclick`, `onchange`, `onload` и т.д.).
   - Все обработчики событий описываются во внешних JS-модулях и навешиваются программно.

2. **Структура без поведения**
   - Разметка должна формировать только структурный и семантический HTML.
   - Для взаимодействия компонентов применяются `data-*` атрибуты, описывающие идентификаторы действий, параметры и состояния.

3. **Размещение сценариев**
   - Подключение базового модуля `Energine.js` выполняется тегом `<script type="module" src="/path/to/Energine.js"></script>` перед `</body>` либо сразу после завершающего содержимого, чтобы гарантировать готовность DOM.
   - Дополнительные модули подключаются аналогично как ES6-модули либо входят в собранный бандл.

## 3. Конфигурация через `data-*`

1. **Основной контейнер конфигурации**
   - Для страниц, требующих инициализации Energine, на элемент `<body>` добавляется атрибут `data-energine-run="1"`.
   - Дополнительные параметры (режим отладки, базовый путь, язык локализации и др.) передаются через `data-*` атрибуты либо на `<body>`, либо на тег `<script src="Energine.js">`.

2. **Чтение конфигурации**
   - Метод `Energine.readConfigFromScriptDataset()` должен использоваться для формирования объекта конфигурации из `dataset` соответствующего тега `<script>`.
   - Полученный объект передается в `Energine.boot(config)`.

3. **Минимизация серверной логики**
   - XSLT-шаблоны формируют только значения `data-*` атрибутов. Никаких JS-функций или выражений в шаблонах не допускается.

## 4. Инициализация клиентской части

1. **Точка входа**
   - После загрузки DOM (`DOMContentLoaded`) либо при выполнении скрипта, размещенного в конце `body`, модуль `Energine.js` проверяет наличие флага `data-energine-run`.
   - При наличии флага выполняется `Energine.boot(config)` с конфигурацией, прочитанной из `data-*` атрибутов.
   - При отсутствии флага инициализация пропускается, что позволяет использовать общие шаблоны без избыточного кода.

2. **Поддержка режимов**
   - В режиме разработки допускается подключение исходных ES6-модулей без предварительной сборки.
   - В продуктивном режиме используется собранный минифицированный бандл, но интерфейс инициализации остается неизменным.

## 5. Тулбар и элементы управления

1. **Генерация разметки**
   - Тулбар и кнопки генерируются XSLT как чистый HTML. Пример структуры:
     ```html
     <div class="toolbar" data-toolbar="main">
       <button type="button" data-action="add" data-confirm="Добавить запись?">
         <i class="fa fa-plus"></i>
         <span>Добавить</span>
       </button>
     </div>
     ```
   - Все параметры поведения описываются через `data-action`, `data-confirm`, `data-disabled`, `data-i18n` и аналогичные атрибуты.

2. **Привязка поведения**
   - Класс `Toolbar` (либо специализированные модули) ищет элементы по селекторам `[data-action]` и назначает обработчики через `addEventListener`.
   - Логика действий реализуется в JavaScript, используя значения атрибутов. Пример:
     ```javascript
     document.addEventListener('DOMContentLoaded', () => {
       document.querySelectorAll('[data-action]').forEach((button) => {
         button.addEventListener('click', () => Toolbar.handleAction(button));
       });
     });
     ```

3. **Расширяемость**
   - Новые типы кнопок или действий добавляются путем расширения модулей JS без изменения XSLT.
   - XSLT отвечает за структуру, визуальное оформление, локализацию подписей и иконок.

## 6. Требования к совместимости

1. **Поддерживаемые браузеры**
   - Минимальные требования — современные версии браузеров с поддержкой ES6-модулей.
   - Для старых браузеров (если требуется) предоставляется сборка-бандл, совместимая с ES5, подключаемая условно.

2. **Совместимость с существующим кодом**
   - Постепенная миграция: допускается временное сосуществование старых и новых шаблонов при условии, что в новых шаблонах соблюдается запрет на inline JS.
   - Депрецированный код собирается в отдельные задачи на удаление.

## 7. Тестирование и приемка

1. **Проверки**
   - Визуальная проверка административных интерфейсов на корректность отображения и работы тулбаров.
   - Проверка отсутствия inline-скриптов в генерируемом HTML.
   - Валидация передачи конфигурации через `data-*` и корректной инициализации `Energine.boot()`.

2. **Документация**
   - Обновление разработческой документации с примерами новых шаблонов и модулей.
   - Подготовка руководства по миграции для команд, отвечающих за XSLT и JS.

## 8. Критерии завершения

- Все административные страницы используют новую схему инициализации без inline JS.
- Конфигурационные параметры полностью передаются через `data-*` атрибуты.
- Тулбар и элементы управления реализованы через семантическую разметку и подключаемое поведение.
- В режиме разработки проект запускается без сборки через подключение ES6-модулей.
- Документация обновлена и доступна команде разработки.

## 9. Анализ текущего состояния

### 9.1. Energine.js

- Базовый модуль насчитывает 882 строки и объединяет в одном файле конфигурацию, мост между `window` и рантаймом, сетевые
  помощники, Bootstrap-модальные окна, тосты и оверлеи загрузчика.【F:engine/core/modules/share/scripts/Energine.js†L1-L882】
- Текущая реализация `initBridge`/`__energineBridge` удерживает отложенные задания и конфигурацию, усложняя загрузку и увеличивая
  объем кода, который можно заменить детерминированным порядком инициализации.【F:engine/core/modules/share/scripts/Energine.js†L37-L200】
- Функция `request` сочетает несколько код-путей (form-urlencoded, JSON, GET) и вызывает `alert`, что препятствует повторному
  использованию и усложняет перенос на промисы/`fetch`-утилиты.【F:engine/core/modules/share/scripts/Energine.js†L305-L393】
- UI-хелперы (`confirmBox`, `alertBox`, `noticeBox`, `showLoader`) встраивают Bootstrap- и FontAwesome-разметку, что увеличивает
  минимальный размер ядра даже для страниц без админки.【F:engine/core/modules/share/scripts/Energine.js†L425-L838】
- Минификация выполняется средствами Vite, однако отсутствие модульного деления приводит к включению в бандл вспомогательных
  функций, которые не используются на большинстве страниц и лишь сжимаются вместо исключения.
- Внутри файла присутствуют устаревшие заглушки (`singleMode`, `legacyToolbar`), которые больше не вызываются и лишь увеличивают
  объём бандла.【F:engine/core/modules/share/scripts/Energine.js†L520-L750】

**Требуемые действия**

1. Выделить ядро (чтение `dataset`, очередь задач, API конфигурации) в отдельный модуль и подключать UI/сетевые модули по
   мере необходимости, уменьшая обязательный бандл.【F:engine/core/modules/share/scripts/Energine.js†L37-L393】
2. Переписать сетевой слой на отдельный модуль, возвращающий промисы/`async`-результаты без побочных эффектов UI, чтобы его можно
   было переиспользовать в разных пакетах.【F:engine/core/modules/share/scripts/Energine.js†L305-L393】
3. Вынести Bootstrap-зависимые компоненты и оверлеи в модуль админ-интерфейса, оставив ядру только текстовые фолбэки.
   【F:engine/core/modules/share/scripts/Energine.js†L425-L838】
4. Сохранить тонкий адаптер `attachToWindow` как обратную совместимость и планомерно отказаться от глобального моста после
   миграции страниц.【F:engine/core/modules/share/scripts/Energine.js†L790-L838】
5. Провести инвентаризацию экспортируемых функций (`queueTask`, `registerToolbar`, `setStyles` и т.д.) и удалить сценарии,
   которые не используются в XSLT или модулях, чтобы Vite мог исключать их из итогового бандла на этапе tree shaking.
6. Собрать карту зависимостей и зафиксировать, какие подсистемы (тулбары, модальные окна, загрузчик) реально требуются в
   продуктиве; по умолчанию они не входят в ядро и подключаются только из страниц, где присутствуют соответствующие `data-*`
   атрибуты.

### 9.2. `document.xslt`

- Шаблон всегда подключает вендорные бандлы и Energine-модуль, даже если страница не требует административного функционала,
  что увеличивает ненужный трафик для публичных страниц.【F:engine/core/modules/share/transformers/bootstrap/document.xslt†L162-L203】
- Внутри шаблона остаются встроенные `<script type="module">`, которые импортируют `bootEnergine`, управляют тулбарами и
  объектами, тем самым нарушая принцип «структура без поведения».【F:engine/core/modules/share/transformers/bootstrap/document.xslt†L177-L260】
- Комментарии с устаревшим inline-JS (например, `window.singleMode`) создают шум при ревью и должны быть удалены вместе с
  переносом логики в модули.【F:engine/core/modules/share/transformers/bootstrap/document.xslt†L137-L144】

**Требуемые действия**

1. Добавить условия для подключения скриптов и стилей только на страницах с `data-energine-run="1"` и необходимыми
   компонентами.【F:engine/core/modules/share/transformers/bootstrap/document.xslt†L162-L205】
2. Перенести запуск `bootEnergine`, регистрацию тулбаров и работу с `componentToolbars` в модуль `Energine.js`/отдельные
   контроллеры, оставив XSLT только генерацию `data-*` атрибутов.【F:engine/core/modules/share/transformers/bootstrap/document.xslt†L205-L260】
3. Удалить устаревшие комментарии и подготовить чистую разметку для отслеживания внедрения unobtrusive JS.

### 9.3. `toolbar.xslt`

- Кнопки тулбара до сих пор генерируют `onclick`-атрибуты, напрямую ссылающиеся на методы JS, что препятствует декларативной
  привязке поведения.【F:engine/core/modules/share/transformers/bootstrap/toolbar.xslt†L55-L166】
- Шаблон содержит встроенный `<script type="module">`, который импортирует `queueTask` и `Toolbar`, а затем программно
  заполняет тулбары, что нарушает требование об отсутствии inline JS.【F:engine/core/modules/share/transformers/bootstrap/toolbar.xslt†L178-L219】
- Оставшиеся комментарии с `setStyles` указывают на зависимость от ручных расчётов высоты, которую необходимо заменить
  CSS-классами и JS-модулями вне XSLT.【F:engine/core/modules/share/transformers/bootstrap/toolbar.xslt†L192-L204】

**Требуемые действия**

1. Заменить `onclick` на `data-action`, `data-confirm` и дополнительные атрибуты состояния, чтобы JS-модули могли навешивать
   обработчики через `addEventListener`.
2. Переместить инициализацию тулбаров в модуль (например, `ToolbarController`), который запускается из Energine после чтения
   конфигурации страницы.【F:engine/core/modules/share/transformers/bootstrap/toolbar.xslt†L178-L219】
3. Переработать расчёт размеров с помощью CSS-макетов и служебных классов вместо встроенных комментариев.

### 9.4. Конфигурационные XML компонентов

- Текущие определения (`*.component.xml`) остаются неизменными и используются как источник данных для XSLT; модернизация
  поведения выполняется на уровне шаблонов и клиентских модулей.
- При разработке модульных контроллеров необходимо учитывать существующую схему `onclick`/`loader="classic"`, обеспечив
  совместимость путём интерпретации этих настроек в JS без модификации самих XML-файлов.

**Требуемые действия**

1. Сохранить схемы `*.component.xml` без изменений, документировав точки расширения для чтения их параметров из JS.
2. Реализовать слой преобразования, который конвертирует существующие параметры (`onclick`, `loader`) в `data-*` атрибуты при
   генерации разметки, чтобы переход к unobtrusive JS не требовал переписывания конфигураций.
3. Обеспечить тесты, подтверждающие, что новые контроллеры корректно работают с существующими XML-настройками без их правки.

## 10. План поэтапного рефакторинга

1. **Оптимизировать Energine.js**: выделить конфигурационный/очередной функционал в отдельный модуль, удалить неиспользуемые
   помощники и подключать UI/сетевые части по требованию (lazy-load или условные импорты), чтобы уменьшить объём кода, который
   попадает в бандл ещё до минификации Vite. При ревизии каждый экспорт проверяется на фактическое использование; мёртвый код
   удаляется, а избыточные зависимости заменяются точечными импортами.【F:engine/core/modules/share/scripts/Energine.js†L37-L838】
2. **Очистить шаблоны**: обновить `document.xslt` и `toolbar.xslt`, чтобы они генерировали только разметку с `data-*` и не
   содержали `<script>`, перенести логику загрузки тулбаров в JS-модули. При этом любая информация, приходящая из
   `*.component.xml`, транслируется в `data-*` без изменений исходных XML.【F:engine/core/modules/share/transformers/bootstrap/document.xslt†L162-L260】【F:engine/core/modules/share/transformers/bootstrap/toolbar.xslt†L55-L219】
3. **Ввести модульные контроллеры**: реализовать тонкие JS-адаптеры внутри существующих файлов, которые читают конфигурацию из
   `*.component.xml`, не изменяя их схему, и обеспечивают работу тулбаров и форм через `data-*` атрибуты. Новые контроллеры
   подключаются через условные импорты, чтобы страницы без тулбаров не тянули лишний код.
4. **Ввести контроль качества**: добавить статический анализ (например, линтер XSLT/HTML) и тесты, проверяющие, что в рендере
   нет `onclick` и что ядро Energine остаётся модульным после дальнейших правок. Дополнительно настроить отчёты о размере
   бандлов, чтобы фиксировать эффект от удаления кода, а не от минификации.
