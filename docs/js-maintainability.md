# Анализ дублирования и сложностей поддержки JavaScript-кода

## Повторяющиеся классы модулей тестового раздела
В каталоге `engine/core/modules/auto/scripts/` присутствуют сразу три класса `Test`, `TestFeed` и `Testfeed`, которые отличаются только регистром имени и порядком вызова `getElementById`/`querySelector`, но дублируют одну и ту же логику поиска DOM-элемента, чтения атрибута `template` и экспорта с хелпером `attachToWindow`. Это классический копипаст, усложняющий любые изменения в компоненте — исправления нужно вносить синхронно в несколько файлов. 【F:engine/core/modules/auto/scripts/Test.js†L1-L26】【F:engine/core/modules/auto/scripts/TestFeed.js†L1-L26】【F:engine/core/modules/auto/scripts/Testfeed.js†L1-L26】

### Почему это проблема
* Любое изменение конструктора или экспортируемого API придётся повторять во всех трёх файлах.
* Лёгко получить рассинхронизацию — уже сейчас порядок вызова `getElementById` и `querySelector` не совпадает, что усложняет понимание, какой вариант «правильный».
* Наличие файлов, отличающихся только регистром, негативно влияет на поддержку на файловых системах без учёта регистра.

### Пошаговый план устранения
1. **Выбрать каноничное имя файла** (например, `Test.js`) и зафиксировать его в бандле/билд-скриптах.
2. **Свести расхождения конструктора** к единой версии (рекомендуется использовать `querySelector`, так как он поддерживает CSS-селекторы). Проверить, что получение `template` вынесено в одну переменную. 【F:engine/core/modules/auto/scripts/Test.js†L9-L24】
3. **Удалить дублирующие файлы** и настроить alias в require/import (если используется) — это позволит сохранить обратную совместимость при минимуме правок.
4. **Добавить unit-тест или smoke-тест для компонента** (например, инициализация с DOM fixture), чтобы зафиксировать поведение и предотвратить повторное расхождение.
5. **Автоматизировать проверку регистра имён** через линтер/скрипт в CI, чтобы новые файлы не появлялись в разных вариантах.

## Повторяемый шаблон глобального экспорта
Практически все скрипты движка содержат одинаковый шаблон объявления `const globalScope = ...` и функцию `attachToWindow`, которая навешивает класс на `window`. Примеры можно увидеть в `ModalBox`, `Toolbar`, `DivForm`, `FileRepoForm`, `AttachmentEditor` и десятках других файлов. 【F:engine/core/modules/share/scripts/ModalBox.js†L1-L68】【F:engine/core/modules/share/scripts/ModalBox.js†L556-L568】【F:engine/core/modules/share/scripts/Toolbar.js†L1-L76】【F:engine/core/modules/share/scripts/DivForm.js†L1-L103】【F:engine/core/modules/share/scripts/FileRepoForm.js†L1-L102】【F:engine/core/modules/share/scripts/AttachmentEditor.js†L1-L88】

### Почему это проблема
* Любое изменение подхода к публикации классов придётся проводить одновременно во всех файлах.
* Распыление одинакового кода затрудняет поиск реальной логики компонента — первые ~20 строк почти каждого файла заняты служебным шаблоном.
* Невозможно централизованно переопределить поведение (например, отключить автоматическое навешивание глобальных переменных) без массовой правки.

### Возможные улучшения
* Вынести логику определения `globalScope` и навешивания на `window` в общий helper и переиспользовать его.
* Рассмотреть модульную загрузку (ESM/UMD) вместо принудительного экспорта в глобальный объект.

### Как сократить количество `attachToWindow`
1. **Создать единый модуль экспорта.** Вынесите текущую функцию `attachToWindow` в новый файл (например, `engine/core/modules/share/scripts/exportToWindow.js`) и замените все локальные копии на импорт этого helper'а. Это сразу сократит количество объявлений до одного.
2. **Добавить фабрику регистрации.** Вместо ручного вызова `attachToWindow(ClassName)` в каждом модуле можно подключать новый helper, который принимает карту экспортируемых сущностей. Тогда отдельный скрипт-реестр (например, `engine/core/modules/share/scripts/bootstrap.js`) будет регистрировать их в `window`, а компонентам достаточно экспортировать свои классы.
3. **Постепенно переводить модули на ESM.** Для новых файлов используйте `export default`/`export` и подключайте их через bundler (Webpack, Rollup, Vite). Для обратной совместимости можно сохранять глобальную регистрацию только в одном месте — в сборке, которая при необходимости делает `window.ClassName = module`. По мере миграции доля ручных `attachToWindow` будет уменьшаться до нуля.

### Дополнительные меры
* **Отслеживание в статистике.** Добавьте шаг в CI, который ищет строки `attachToWindow(` и выводит их количество. Это позволит видеть динамику после каждого рефакторинга.
* **Временный polyfill.** После создания общего helper'а можно добавить предупреждение `console.warn` при прямом вызове `attachToWindow`, чтобы разработчики переходили на `registerGlobalComponent({ ... })`.
* **Документация для новых модулей.** Обновите гайдлайн по JavaScript, включив пример с импортом общего helper'а и запретом копировать шаблон `const globalScope = ...`.
* **План миграции на ESM.** Начинайте с изолированных модулей (`ModalBox`, `Toolbar`) и постепенно переносите зависимые компоненты, фиксируя список в таск-трекере, чтобы не потерять прогресс.

## Дублирование логики загрузки файлов
Компоненты управления файлами (`AttachmentEditor`, `FileRepoForm`, `FileRepository`) содержат практически идентичные реализации метода `xhrFileUpload`: настройка прогресс-бара, построение запроса `upload-temp`, обработка JSON-ответа и прогресса. Различия минимальны (дополнительные параметры `pid`). 【F:engine/core/modules/share/scripts/AttachmentEditor.js†L1-L140】【F:engine/core/modules/share/scripts/AttachmentEditor.js†L188-L228】【F:engine/core/modules/share/scripts/FileRepoForm.js†L1-L115】【F:engine/core/modules/share/scripts/FileRepoForm.js†L67-L119】【F:engine/core/modules/share/scripts/FileRepository.js†L1-L120】【F:engine/core/modules/share/scripts/FileRepository.js†L510-L596】

### Почему это проблема
* Исправление ошибок в загрузчике (например, обработка сетевых сбоев) нужно повторять в трёх местах.
* Из-за разных копий легко получить несовместимое поведение — уже сейчас один вариант принимает `pidOverride`, другой — нет.
* Тестирование усложняется: требуется гонять сценарии для каждого компонента, хотя логика одинаковая.

### Возможные улучшения
* Вынести общий загрузчик в `nativeFileHelpers.js` или отдельный модуль, а в компонентах оставлять только настройку коллбеков.
* Создать базовый класс «загрузчик с прогрессом» и переиспользовать его.

### Пошаговый план унификации
1. **Собрать отличия** (например, поддержка `pidOverride`, настройка прогресса) и оформить их как параметры/хуки общего сервиса. 【F:engine/core/modules/share/scripts/FileRepoForm.js†L67-L119】【F:engine/core/modules/share/scripts/FileRepository.js†L544-L596】
2. **Создать модуль `uploadService.js`** с функциями `createUploader(config)` и `performUpload({ endpoint, data, onProgress })`. Общие части (работа с `XMLHttpRequest`, обработка `progress`, обновление DOM) разместить внутри него. 【F:engine/core/modules/share/scripts/AttachmentEditor.js†L188-L228】
3. **Инкапсулировать связь с DOM** через интерфейсы (например, `onProgress`, `onSuccess`, `onError`), чтобы компоненты не зависели от внутренней реализации прогресс-бара.
4. **Мигрировать компоненты последовательно**, начиная с самого малого (`AttachmentEditor`), и после каждого шага запускать smoke-тест загрузки в админке.
5. **Удалить дубликаты и добавить модульные тесты** (можно мокать `XMLHttpRequest`), чтобы предотвратить повторное копирование кода.

## Монолитный класс формы
`engine/core/modules/share/scripts/Form.js` содержит 2119 строк и совмещает в себе десятки разных обязанностей: управление вкладками, загрузку файлов, инициализацию CKEditor, работу с «богатыми» редакторами, селекторы sitemap и т.д. В файле объявлены и основная форма, и вложенные классы (`Form.Uploader`, `Form.SmapSelector`, `Form.AttachmentSelector` и др.), причём каждая сущность реализует собственную сложную логику в рамках одного файла. 【F:engine/core/modules/share/scripts/Form.js†L1-L120】【F:engine/core/modules/share/scripts/Form.js†L1680-L1760】【F:engine/core/modules/share/scripts/Form.js†L1743-L1794】【F:engine/core/modules/share/scripts/Form.js†L1795-L1880】【F:engine/core/modules/share/scripts/Form.js†L1881-L1972】

### Почему это проблема
* Из-за объёма файла сложно найти нужный участок и отследить зависимости между вложенными классами.
* Любые изменения требуют перепроверять большое количество неочевидных связей — например, `Form.Uploader` напрямую модифицирует DOM, а `Form.SmapSelector` открывает модальные окна, что затрудняет unit-тестирование.
* Совмещены как базовые API-методы, так и UI-утилиты (иконки предпросмотра, работа с Cookie), что затрудняет переиспользование.

### Возможные улучшения
* Разделить файл на модули: основной контроллер формы, отдельные классы для загрузчика, селекторов, работы с preview.
* Инкапсулировать работу с DOM и внешними библиотеками в отдельные сервисы или адаптеры.

### Рекомендованная декомпозиция
1. **CoreForm** — класс, отвечающий только за жизненный цикл формы, валидацию и переключение вкладок. Код конструктора инициализации контролов (строки 315–420) переместить сюда. 【F:engine/core/modules/share/scripts/Form.js†L315-L420】
2. **FormUploadService** — вынести логику `Form.Uploader` в отдельный файл с чётким API (`init`, `upload`, `reset`). 【F:engine/core/modules/share/scripts/Form.js†L1670-L1745】
3. **ModalSelectors** — оформить `Form.SmapSelector` и `Form.AttachmentSelector` в модуль с единым интерфейсом `openSelector`. Это позволит переиспользовать модальные окна вне формы. 【F:engine/core/modules/share/scripts/Form.js†L1747-L1872】
4. **Adapters для сторонних библиотек** — создать обёртки `ckeditorAdapter.js`, `codeMirrorAdapter.js`, которые будут отвечать за подключение редакторов (строки 352–372). 【F:engine/core/modules/share/scripts/Form.js†L352-L372】
5. **Отдельные entry-пойнты** — разбить `Form.js` на пакет модулей и собрать их через bundler, что сократит время загрузки и облегчит тестирование.

## Крупный класс панели инструментов
`engine/core/modules/share/scripts/Toolbar.js` содержит 860 строк и описывает сразу несколько типов контролов (кнопки, выпадающие меню, группы), управляет DOM-структурами, состоянием и событиями. Всё это находится в одном классе, а вспомогательные подклассы объявлены непосредственно внутри файла. 【F:engine/core/modules/share/scripts/Toolbar.js†L1-L120】【F:engine/core/modules/share/scripts/Toolbar.js†L121-L220】【F:engine/core/modules/share/scripts/Toolbar.js†L221-L320】

### Почему это проблема
* В отсутствие явного разделения по файлам трудно переиспользовать отдельные контролы или протестировать их изоляционно.
* Изменение API одного подкласса легко ломает остальные, потому что они зависят от общих приватных соглашений (например, структуры `this.controls`).
* Такой файл тяжело грузить постепенно — любой импорт подтянет весь объём кода, даже если нужен один тип кнопки.

### Возможные улучшения
* Разбить компоненты панели на отдельные модули/классы и оставить в `Toolbar` только сборку и управление контейнером.
* Добавить фабрики или реестр контролов вместо жёстких `switch`.

### Предлагаемый рефакторинг
1. **Выделить базовую сущность `ToolbarControl`** (уже присутствует как вложенный класс) в отдельный файл и подключать через `import`. Это позволит создавать дополнительные контролы без изменения основного класса. 【F:engine/core/modules/share/scripts/Toolbar.js†L168-L220】
2. **Создать реестр контролов**: объект `controlRegistry`, где ключ — `type`, а значение — класс. Тогда метод `appendControl` сможет запрашивать контрол через `registry.get(type)` вместо `switch`. 【F:engine/core/modules/share/scripts/Toolbar.js†L20-L75】
3. **Разделить ответственность за Bootstrap-интеграцию**: вынести проверки `hasBootstrapStyles/Script` и методы `createBootstrapTooltip/Dropdown` в модуль `toolbarBootstrap.js`. 【F:engine/core/modules/share/scripts/Toolbar.js†L128-L164】
4. **Добавить тесты на фабрику** — простая проверка, что JSON-описание тулбара с разными типами контролов собирается корректно, поможет фиксировать API и сократит риск регрессий.

## Общий план внедрения

1. **Приоритизация**: начать с устранения дублирующих файлов (`Test*`) и унификации `attachToWindow`, потому что эти задачи затрагивают десятки модулей и сразу уменьшают технический долг.
2. **Создание вспомогательных пакетов**: подготовить директорию `engine/core/modules/share/scripts/helpers/` для общих сервисов (глобальный экспорт, загрузка файлов, адаптеры к библиотекам) и вынести туда код из монолитов.
3. **Постепенная миграция**: после появления общих helper'ов переносить по 2–3 компонента за итерацию, фиксируя прогресс в таблице (сколько файлов ещё содержит `attachToWindow`, сколько — старый шаблон загрузки).
4. **Инструменты контроля качества**: добавить линтер (ESLint) с правилами против глобальных синглтонов и копипаста, включить `eslint-plugin-you-dont-need-lodash-underscore` и `eslint-plugin-import` для контроля зависимостей.
5. **Документация и обучение**: провести внутренний воркшоп/демо по новым helper'ам и процессу миграции, чтобы команда использовала обновлённый подход при разработке новых модулей.

Такой детализированный план позволит не только зафиксировать проблемные места, но и поэтапно избавляться от дублирующегося и трудно поддерживаемого JavaScript-кода.
