# Анализ дублирования и сложностей поддержки JavaScript-кода

## Повторяющиеся классы модулей тестового раздела
В каталоге `engine/core/modules/auto/scripts/` присутствуют сразу три класса `Test`, `TestFeed` и `Testfeed`, которые отличаются только регистром имени и порядком вызова `getElementById`/`querySelector`, но дублируют одну и ту же логику поиска DOM-элемента, чтения атрибута `template` и экспорта с хелпером `attachToWindow`. Это классический копипаст, усложняющий любые изменения в компоненте — исправления нужно вносить синхронно в несколько файлов. 【F:engine/core/modules/auto/scripts/Test.js†L1-L26】【F:engine/core/modules/auto/scripts/TestFeed.js†L1-L26】【F:engine/core/modules/auto/scripts/Testfeed.js†L1-L26】

### Почему это проблема
* Любое изменение конструктора или экспортируемого API придётся повторять во всех трёх файлах.
* Лёгко получить рассинхронизацию — уже сейчас порядок вызова `getElementById` и `querySelector` не совпадает, что усложняет понимание, какой вариант «правильный».
* Наличие файлов, отличающихся только регистром, негативно влияет на поддержку на файловых системах без учёта регистра.

## Повторяемый шаблон глобального экспорта
Практически все скрипты движка содержат одинаковый шаблон объявления `const globalScope = ...` и функцию `attachToWindow`, которая навешивает класс на `window`. Примеры можно увидеть в `ModalBox`, `Toolbar`, `DivForm`, `FileRepoForm`, `AttachmentEditor` и десятках других файлов. 【F:engine/core/modules/share/scripts/ModalBox.js†L1-L68】【F:engine/core/modules/share/scripts/ModalBox.js†L556-L568】【F:engine/core/modules/share/scripts/Toolbar.js†L1-L76】【F:engine/core/modules/share/scripts/DivForm.js†L1-L103】【F:engine/core/modules/share/scripts/FileRepoForm.js†L1-L102】【F:engine/core/modules/share/scripts/AttachmentEditor.js†L1-L88】

### Почему это проблема
* Любое изменение подхода к публикации классов придётся проводить одновременно во всех файлах.
* Распыление одинакового кода затрудняет поиск реальной логики компонента — первые ~20 строк почти каждого файла заняты служебным шаблоном.
* Невозможно централизованно переопределить поведение (например, отключить автоматическое навешивание глобальных переменных) без массовой правки.

### Возможные улучшения
* Вынести логику определения `globalScope` и навешивания на `window` в общий helper и переиспользовать его.
* Рассмотреть модульную загрузку (ESM/UMD) вместо принудительного экспорта в глобальный объект.

### Как сократить количество `attachToWindow`
1. **Создать единый модуль экспорта.** Вынесите текущую функцию `attachToWindow` в новый файл (например, `engine/core/modules/share/scripts/exportToWindow.js`) и замените все локальные копии на импорт этого helper'а. Это сразу сократит количество объявлений до одного.
2. **Добавить фабрику регистрации.** Вместо ручного вызова `attachToWindow(ClassName)` в каждом модуле можно подключать новый helper, который принимает карту экспортируемых сущностей. Тогда отдельный скрипт-реестр (например, `engine/core/modules/share/scripts/bootstrap.js`) будет регистрировать их в `window`, а компонентам достаточно экспортировать свои классы.
3. **Постепенно переводить модули на ESM.** Для новых файлов используйте `export default`/`export` и подключайте их через bundler (Webpack, Rollup, Vite). Для обратной совместимости можно сохранять глобальную регистрацию только в одном месте — в сборке, которая при необходимости делает `window.ClassName = module`. По мере миграции доля ручных `attachToWindow` будет уменьшаться до нуля.

## Дублирование логики загрузки файлов
Компоненты управления файлами (`AttachmentEditor`, `FileRepoForm`, `FileRepository`) содержат практически идентичные реализации метода `xhrFileUpload`: настройка прогресс-бара, построение запроса `upload-temp`, обработка JSON-ответа и прогресса. Различия минимальны (дополнительные параметры `pid`). 【F:engine/core/modules/share/scripts/AttachmentEditor.js†L1-L140】【F:engine/core/modules/share/scripts/AttachmentEditor.js†L188-L228】【F:engine/core/modules/share/scripts/FileRepoForm.js†L1-L115】【F:engine/core/modules/share/scripts/FileRepoForm.js†L67-L119】【F:engine/core/modules/share/scripts/FileRepository.js†L1-L120】【F:engine/core/modules/share/scripts/FileRepository.js†L510-L596】

### Почему это проблема
* Исправление ошибок в загрузчике (например, обработка сетевых сбоев) нужно повторять в трёх местах.
* Из-за разных копий легко получить несовместимое поведение — уже сейчас один вариант принимает `pidOverride`, другой — нет.
* Тестирование усложняется: требуется гонять сценарии для каждого компонента, хотя логика одинаковая.

### Возможные улучшения
* Вынести общий загрузчик в `nativeFileHelpers.js` или отдельный модуль, а в компонентах оставлять только настройку коллбеков.
* Создать базовый класс «загрузчик с прогрессом» и переиспользовать его.

## Монолитный класс формы
`engine/core/modules/share/scripts/Form.js` содержит 2119 строк и совмещает в себе десятки разных обязанностей: управление вкладками, загрузку файлов, инициализацию CKEditor, работу с «богатыми» редакторами, селекторы sitemap и т.д. В файле объявлены и основная форма, и вложенные классы (`Form.Uploader`, `Form.SmapSelector`, `Form.AttachmentSelector` и др.), причём каждая сущность реализует собственную сложную логику в рамках одного файла. 【F:engine/core/modules/share/scripts/Form.js†L1-L120】【F:engine/core/modules/share/scripts/Form.js†L1680-L1760】【F:engine/core/modules/share/scripts/Form.js†L1743-L1794】【F:engine/core/modules/share/scripts/Form.js†L1795-L1880】【F:engine/core/modules/share/scripts/Form.js†L1881-L1972】

### Почему это проблема
* Из-за объёма файла сложно найти нужный участок и отследить зависимости между вложенными классами.
* Любые изменения требуют перепроверять большое количество неочевидных связей — например, `Form.Uploader` напрямую модифицирует DOM, а `Form.SmapSelector` открывает модальные окна, что затрудняет unit-тестирование.
* Совмещены как базовые API-методы, так и UI-утилиты (иконки предпросмотра, работа с Cookie), что затрудняет переиспользование.

### Возможные улучшения
* Разделить файл на модули: основной контроллер формы, отдельные классы для загрузчика, селекторов, работы с preview.
* Инкапсулировать работу с DOM и внешними библиотеками в отдельные сервисы или адаптеры.

## Крупный класс панели инструментов
`engine/core/modules/share/scripts/Toolbar.js` содержит 860 строк и описывает сразу несколько типов контролов (кнопки, выпадающие меню, группы), управляет DOM-структурами, состоянием и событиями. Всё это находится в одном классе, а вспомогательные подклассы объявлены непосредственно внутри файла. 【F:engine/core/modules/share/scripts/Toolbar.js†L1-L120】【F:engine/core/modules/share/scripts/Toolbar.js†L121-L220】【F:engine/core/modules/share/scripts/Toolbar.js†L221-L320】

### Почему это проблема
* В отсутствие явного разделения по файлам трудно переиспользовать отдельные контролы или протестировать их изоляционно.
* Изменение API одного подкласса легко ломает остальные, потому что они зависят от общих приватных соглашений (например, структуры `this.controls`).
* Такой файл тяжело грузить постепенно — любой импорт подтянет весь объём кода, даже если нужен один тип кнопки.

### Возможные улучшения
* Разбить компоненты панели на отдельные модули/классы и оставить в `Toolbar` только сборку и управление контейнером.
* Добавить фабрики или реестр контролов вместо жёстких `switch`.
