# Анализ дублирования и сложностей поддержки JavaScript-кода

## Повторяющиеся классы модулей тестового раздела
В каталоге `engine/core/modules/auto/scripts/` присутствуют сразу три класса `Test`, `TestFeed` и `Testfeed`, которые отличаются только регистром имени и порядком вызова `getElementById`/`querySelector`, но дублируют одну и ту же логику поиска DOM-элемента, чтения атрибута `template` и экспорта с хелпером `attachToWindow`. Это классический копипаст, усложняющий любые изменения в компоненте — исправления нужно вносить синхронно в несколько файлов. 【F:engine/core/modules/auto/scripts/Test.js†L1-L26】【F:engine/core/modules/auto/scripts/TestFeed.js†L1-L26】【F:engine/core/modules/auto/scripts/Testfeed.js†L1-L26】

### Почему это проблема
* Любое изменение конструктора или экспортируемого API придётся повторять во всех трёх файлах.
* Лёгко получить рассинхронизацию — уже сейчас порядок вызова `getElementById` и `querySelector` не совпадает, что усложняет понимание, какой вариант «правильный».
* Наличие файлов, отличающихся только регистром, негативно влияет на поддержку на файловых системах без учёта регистра.

### Пошаговый план устранения
1. **Выбрать каноничное имя файла** (например, `Test.js`) и зафиксировать его в бандле/билд-скриптах.
2. **Свести расхождения конструктора** к единой версии (рекомендуется использовать `querySelector`, так как он поддерживает CSS-селекторы). Проверить, что получение `template` вынесено в одну переменную. 【F:engine/core/modules/auto/scripts/Test.js†L9-L24】
3. **Удалить дублирующие файлы** и настроить alias в require/import (если используется) — это позволит сохранить обратную совместимость при минимуме правок.
4. **Добавить unit-тест или smoke-тест для компонента** (например, инициализация с DOM fixture), чтобы зафиксировать поведение и предотвратить повторное расхождение.
5. **Автоматизировать проверку регистра имён** через линтер/скрипт в CI, чтобы новые файлы не появлялись в разных вариантах.

## Повторяемый шаблон глобального экспорта
Практически все скрипты движка содержат одинаковый шаблон объявления `const globalScope = ...` и функцию `attachToWindow`, которая навешивает класс на `window`. Примеры можно увидеть в `ModalBox`, `Toolbar`, `DivForm`, `FileRepoForm`, `AttachmentEditor` и десятках других файлов. 【F:engine/core/modules/share/scripts/ModalBox.js†L1-L68】【F:engine/core/modules/share/scripts/ModalBox.js†L556-L568】【F:engine/core/modules/share/scripts/Toolbar.js†L1-L76】【F:engine/core/modules/share/scripts/DivForm.js†L1-L103】【F:engine/core/modules/share/scripts/FileRepoForm.js†L1-L102】【F:engine/core/modules/share/scripts/AttachmentEditor.js†L1-L88】

### Почему это проблема
* Любое изменение подхода к публикации классов придётся проводить одновременно во всех файлах.
* Распыление одинакового кода затрудняет поиск реальной логики компонента — первые ~20 строк почти каждого файла заняты служебным шаблоном.
* Невозможно централизованно переопределить поведение (например, отключить автоматическое навешивание глобальных переменных) без массовой правки.

### Возможные улучшения
* Вынести логику определения `globalScope` и навешивания на `window` в общий helper и переиспользовать его.
* Рассмотреть модульную загрузку (ESM/UMD) вместо принудительного экспорта в глобальный объект.

### Как сократить количество `attachToWindow`
1. **Создать единый модуль экспорта.** Вынесите текущую функцию `attachToWindow` в новый файл (например, `engine/core/modules/share/scripts/exportToWindow.js`) и замените все локальные копии на импорт этого helper'а. Это сразу сократит количество объявлений до одного.
2. **Добавить фабрику регистрации.** Вместо ручного вызова `attachToWindow(ClassName)` в каждом модуле можно подключать новый helper, который принимает карту экспортируемых сущностей. Тогда отдельный скрипт-реестр (например, `engine/core/modules/share/scripts/bootstrap.js`) будет регистрировать их в `window`, а компонентам достаточно экспортировать свои классы.
3. **Постепенно переводить модули на ESM.** Для новых файлов используйте `export default`/`export` и подключайте их через bundler (Webpack, Rollup, Vite). Для обратной совместимости можно сохранять глобальную регистрацию только в одном месте — в сборке, которая при необходимости делает `window.ClassName = module`. По мере миграции доля ручных `attachToWindow` будет уменьшаться до нуля.

### Дополнительные меры
* **Отслеживание в статистике.** Добавьте шаг в CI, который ищет строки `attachToWindow(` и выводит их количество. Это позволит видеть динамику после каждого рефакторинга.
* **Временный polyfill.** После создания общего helper'а можно добавить предупреждение `console.warn` при прямом вызове `attachToWindow`, чтобы разработчики переходили на `registerGlobalComponent({ ... })`.
* **Документация для новых модулей.** Обновите гайдлайн по JavaScript, включив пример с импортом общего helper'а и запретом копировать шаблон `const globalScope = ...`.
* **План миграции на ESM.** Начинайте с изолированных модулей (`ModalBox`, `Toolbar`) и постепенно переносите зависимые компоненты, фиксируя список в таск-трекере, чтобы не потерять прогресс.

## Дублирование логики загрузки файлов
Компоненты управления файлами (`AttachmentEditor`, `FileRepoForm`, `FileRepository`) содержат практически идентичные реализации метода `xhrFileUpload`: настройка прогресс-бара, построение запроса `upload-temp`, обработка JSON-ответа и прогресса. Различия минимальны (дополнительные параметры `pid`). 【F:engine/core/modules/share/scripts/AttachmentEditor.js†L1-L140】【F:engine/core/modules/share/scripts/AttachmentEditor.js†L188-L228】【F:engine/core/modules/share/scripts/FileRepoForm.js†L1-L115】【F:engine/core/modules/share/scripts/FileRepoForm.js†L67-L119】【F:engine/core/modules/share/scripts/FileRepository.js†L1-L120】【F:engine/core/modules/share/scripts/FileRepository.js†L510-L596】

### Почему это проблема
* Исправление ошибок в загрузчике (например, обработка сетевых сбоев) нужно повторять в трёх местах.
* Из-за разных копий легко получить несовместимое поведение — уже сейчас один вариант принимает `pidOverride`, другой — нет.
* Тестирование усложняется: требуется гонять сценарии для каждого компонента, хотя логика одинаковая.

### Возможные улучшения
* Вынести общий загрузчик в `nativeFileHelpers.js` или отдельный модуль, а в компонентах оставлять только настройку коллбеков.
* Создать базовый класс «загрузчик с прогрессом» и переиспользовать его.

### Пошаговый план унификации
1. **Собрать отличия** (например, поддержка `pidOverride`, настройка прогресса) и оформить их как параметры/хуки общего сервиса. 【F:engine/core/modules/share/scripts/FileRepoForm.js†L67-L119】【F:engine/core/modules/share/scripts/FileRepository.js†L544-L596】
2. **Создать модуль `uploadService.js`** с функциями `createUploader(config)` и `performUpload({ endpoint, data, onProgress })`. Общие части (работа с `XMLHttpRequest`, обработка `progress`, обновление DOM) разместить внутри него. 【F:engine/core/modules/share/scripts/AttachmentEditor.js†L188-L228】
3. **Инкапсулировать связь с DOM** через интерфейсы (например, `onProgress`, `onSuccess`, `onError`), чтобы компоненты не зависели от внутренней реализации прогресс-бара.
4. **Мигрировать компоненты последовательно**, начиная с самого малого (`AttachmentEditor`), и после каждого шага запускать smoke-тест загрузки в админке.
5. **Удалить дубликаты и добавить модульные тесты** (можно мокать `XMLHttpRequest`), чтобы предотвратить повторное копирование кода.

## Большие монолитные модули

Помимо явных дублей в кодовой базе есть пласты тяжёлых монолитов, которые объединяют разнородные обязанности в одном файле.
Такие модули затрудняют точечные изменения, их невозможно загрузить частями или переиспользовать без подтягивания всего «комбайна»,
а смешение старых и новых API в одном файле усложняет миграцию.

* **`ModalBox.js`** одновременно содержит полифиллы для DOM-API, менеджер состояния модальных окон, механику фокус-трапа
  и прямое управление разметкой/стилями. Все эти задачи живут внутри одного класса на ~560 строк, и малейшее изменение
  требует прогонять весь цикл проверки, даже если нужно поправить только логику закрытия. 【F:engine/core/modules/share/scripts/ModalBox.js†L1-L200】
* **`PageEditor.js`** объединяет современную реализацию `PageEditor` с вложенным `BlockEditor`, а ниже по файлу дублирует
  легаси-версию `BlockEditor` и экспорт в глобальную область, что влечёт конфликты контекстов и двойные зависимости от CKEditor. 【F:engine/core/modules/share/scripts/PageEditor.js†L1-L310】
* **`Form.js`** и **`Toolbar.js`** (описаны ниже) демонстрируют типичную проблему сверхкрупных классов: в одном файле
  находятся как базовые контроллеры, так и вспомогательные утилиты, модальные селекторы, интеграции с внешними библиотеками
  и жёсткие связи с DOM. 【F:engine/core/modules/share/scripts/Form.js†L1-L1972】【F:engine/core/modules/share/scripts/Toolbar.js†L1-L320】

### Риски от монолитов
* **Глубокая связанность.** Внутренние методы обращаются друг к другу напрямую, поэтому невозможно заменить часть логики
  без каскадных правок по всему файлу.
* **Сложное тестирование.** Чтобы протестировать один сценарий (`focus trap` у `ModalBox`), приходится инициализировать весь
  класс со всеми зависимостями и глобальными побочными эффектами.
* **Торможение миграции.** Одновременное наличие легаси- и новой реализации (`PageEditor.BlockEditor` и глобальный `BlockEditor`)
  блокирует переход на модульный импорт: невозможно просто удалить старый код, пока он живёт в одном файле и экспортируется наружу.

### План разукрупнения
1. **Выделить слой инфраструктуры.** Создать директорию `engine/core/modules/share/scripts/components/` и перенести туда
   узкоспециализированные части (`focusTrap`, `modalLayout`, адаптеры к CKEditor). Модули должны экспортировать чистые функции
   или классы без побочных эффектов при импорте.
2. **Сформировать публичные фасады.** Для каждого крупного блока (ModalBox, PageEditor, Form, Toolbar) оставить тонкий файл,
   который собирает зависимости, но не хранит реализацию. Это позволит подключать только необходимые части при бандлинге.
3. **Развести легаси и современный API.** Унести глобальные адаптеры (`attachToWindow`, старый `BlockEditor`) в отдельные файлы
   и подключать их только в легаси-бандле. Основной код должен экспортироваться как ESM/UMD без побочных эффектов. 【F:engine/core/modules/share/scripts/PageEditor.js†L299-L310】
4. **Автоматизировать контроль размера.** Добавить в CI проверку (`eslint-plugin-perf-standard` или собственный скрипт), которая
   падает, если файл превышает заданный порог строк (например, 400). Это поможет удержать новые модули от повторного разрастания.

## Монолитный класс формы
`engine/core/modules/share/scripts/Form.js` содержит 2119 строк и совмещает в себе десятки разных обязанностей: управление вкладками, загрузку файлов, инициализацию CKEditor, работу с «богатыми» редакторами, селекторы sitemap и т.д. В файле объявлены и основная форма, и вложенные классы (`Form.Uploader`, `Form.SmapSelector`, `Form.AttachmentSelector` и др.), причём каждая сущность реализует собственную сложную логику в рамках одного файла. 【F:engine/core/modules/share/scripts/Form.js†L1-L120】【F:engine/core/modules/share/scripts/Form.js†L1680-L1760】【F:engine/core/modules/share/scripts/Form.js†L1743-L1794】【F:engine/core/modules/share/scripts/Form.js†L1795-L1880】【F:engine/core/modules/share/scripts/Form.js†L1881-L1972】

### Почему это проблема
* Из-за объёма файла сложно найти нужный участок и отследить зависимости между вложенными классами.
* Любые изменения требуют перепроверять большое количество неочевидных связей — например, `Form.Uploader` напрямую модифицирует DOM, а `Form.SmapSelector` открывает модальные окна, что затрудняет unit-тестирование.
* Совмещены как базовые API-методы, так и UI-утилиты (иконки предпросмотра, работа с Cookie), что затрудняет переиспользование.

### Возможные улучшения
* Разделить файл на модули: основной контроллер формы, отдельные классы для загрузчика, селекторов, работы с preview.
* Инкапсулировать работу с DOM и внешними библиотеками в отдельные сервисы или адаптеры.

### Рекомендованная декомпозиция
1. **CoreForm** — класс, отвечающий только за жизненный цикл формы, валидацию и переключение вкладок. Код конструктора инициализации контролов (строки 315–420) переместить сюда. 【F:engine/core/modules/share/scripts/Form.js†L315-L420】
2. **FormUploadService** — вынести логику `Form.Uploader` в отдельный файл с чётким API (`init`, `upload`, `reset`). 【F:engine/core/modules/share/scripts/Form.js†L1670-L1745】
3. **ModalSelectors** — оформить `Form.SmapSelector` и `Form.AttachmentSelector` в модуль с единым интерфейсом `openSelector`. Это позволит переиспользовать модальные окна вне формы. 【F:engine/core/modules/share/scripts/Form.js†L1747-L1872】
4. **Adapters для сторонних библиотек** — создать обёртки `ckeditorAdapter.js`, `codeMirrorAdapter.js`, которые будут отвечать за подключение редакторов (строки 352–372). 【F:engine/core/modules/share/scripts/Form.js†L352-L372】
5. **Отдельные entry-пойнты** — разбить `Form.js` на пакет модулей и собрать их через bundler, что сократит время загрузки и облегчит тестирование.

## Крупный класс панели инструментов
`engine/core/modules/share/scripts/Toolbar.js` содержит 860 строк и описывает сразу несколько типов контролов (кнопки, выпадающие меню, группы), управляет DOM-структурами, состоянием и событиями. Всё это находится в одном классе, а вспомогательные подклассы объявлены непосредственно внутри файла. 【F:engine/core/modules/share/scripts/Toolbar.js†L1-L120】【F:engine/core/modules/share/scripts/Toolbar.js†L121-L220】【F:engine/core/modules/share/scripts/Toolbar.js†L221-L320】

### Почему это проблема
* В отсутствие явного разделения по файлам трудно переиспользовать отдельные контролы или протестировать их изоляционно.
* Изменение API одного подкласса легко ломает остальные, потому что они зависят от общих приватных соглашений (например, структуры `this.controls`).
* Такой файл тяжело грузить постепенно — любой импорт подтянет весь объём кода, даже если нужен один тип кнопки.

### Возможные улучшения
* Разбить компоненты панели на отдельные модули/классы и оставить в `Toolbar` только сборку и управление контейнером.
* Добавить фабрики или реестр контролов вместо жёстких `switch`.

### Предлагаемый рефакторинг
1. **Выделить базовую сущность `ToolbarControl`** (уже присутствует как вложенный класс) в отдельный файл и подключать через `import`. Это позволит создавать дополнительные контролы без изменения основного класса. 【F:engine/core/modules/share/scripts/Toolbar.js†L168-L220】
2. **Создать реестр контролов**: объект `controlRegistry`, где ключ — `type`, а значение — класс. Тогда метод `appendControl` сможет запрашивать контрол через `registry.get(type)` вместо `switch`. 【F:engine/core/modules/share/scripts/Toolbar.js†L20-L75】
3. **Разделить ответственность за Bootstrap-интеграцию**: вынести проверки `hasBootstrapStyles/Script` и методы `createBootstrapTooltip/Dropdown` в модуль `toolbarBootstrap.js`. 【F:engine/core/modules/share/scripts/Toolbar.js†L128-L164】
4. **Добавить тесты на фабрику** — простая проверка, что JSON-описание тулбара с разными типами контролов собирается корректно, поможет фиксировать API и сократит риск регрессий.

## Общий план внедрения

1. **Приоритизация**: начать с устранения дублирующих файлов (`Test*`) и унификации `attachToWindow`, потому что эти задачи затрагивают десятки модулей и сразу уменьшают технический долг.
2. **Создание вспомогательных пакетов**: подготовить директорию `engine/core/modules/share/scripts/helpers/` для общих сервисов (глобальный экспорт, загрузка файлов, адаптеры к библиотекам) и вынести туда код из монолитов.
3. **Постепенная миграция**: после появления общих helper'ов переносить по 2–3 компонента за итерацию, фиксируя прогресс в таблице (сколько файлов ещё содержит `attachToWindow`, сколько — старый шаблон загрузки).
4. **Инструменты контроля качества**: добавить линтер (ESLint) с правилами против глобальных синглтонов и копипаста, включить `eslint-plugin-you-dont-need-lodash-underscore` и `eslint-plugin-import` для контроля зависимостей.
5. **Документация и обучение**: провести внутренний воркшоп/демо по новым helper'ам и процессу миграции, чтобы команда использовала обновлённый подход при разработке новых модулей.

## Глобальные зависимости и устаревшие подходы

### Глобальный мост Energine
* `Energine.js` инициализирует прокси-мост, привязывает рантайм к `window` и копирует утилиты (`safeConsoleError`, `showLoader`, `hideLoader`) в глобальную область видимости. Из-за этого компонентам сложнее работать изолированно, а тестам — подменять окружение без реального `window`. 【F:engine/core/modules/share/scripts/Energine.js†L1-L167】【F:engine/core/modules/share/scripts/Energine.js†L827-L837】
* Мост подтягивает существующую конфигурацию из `window.Energine`, что делает порядок загрузки критичным: любые расхождения в инициализации приводят к тому, что компоненты читают устаревшие значения. 【F:engine/core/modules/share/scripts/Energine.js†L841-L858】

**Что делать:** зафиксировать явный `bootEnergine(config)` как единственную точку входа, отдавать рантайм через экспорты и DI, а глобальную регистрацию выполнять только в легаси-адаптере. Для тестов обеспечить фабрику, создающую экземпляр без доступа к `window`.

### Требование глобальных библиотек
* `TemplateWizard` напрямую ожидает, что `jQuery` уже записан в `window`, и падает, если библиотека не найдена. Это затрудняет код-сплиттинг и любые попытки перехода на чистый ES-модульный стек. 【F:engine/core/modules/wizard/scripts/TemplateWizard.js†L5-L50】
* `Toolbar` проверяет наличие `window.bootstrap` и обращается к глобальному объекту `bootstrap.*` вместо модульного импорта, из-за чего нельзя гибко обновлять версию Bootstrap и подключать только нужные компоненты. 【F:engine/core/modules/share/scripts/Toolbar.js†L1-L164】
* Загрузчик CKEditor самостоятельно создаёт `<script>` в `document.head`, выставляет `window.CKEDITOR_BASEPATH` и ожидает появление глобального `window.CKEDITOR`. Любые попытки пакетировать редактор вместе с приложением усложняются этими сайд-эффектами. 【F:engine/core/modules/share/scripts/ckeditor/loader.js†L1-L48】

**Что делать:** обернуть внешние библиотеки в адаптеры с явными импортами, перевести зависимости на lazy-import (`import()`), а старый глобальный API поддерживать через шим, который подключается только в легаси-страницах.

### Глобальные конфигурации и обращения к `window`
* `Form` вешает обработчики на `window` и `window.parent.ModalBox`, что требует наличия полноценного DOM и сложной структуры фреймов даже при тестировании отдельных методов. 【F:engine/core/modules/share/scripts/Form.js†L425-L435】
* Для настройки стилей редактора форма ожидает массив `wysiwyg_styles` в глобальной области. Такой контракт не документирован и затрудняет перенос данных в модульные конфиги. 【F:engine/core/modules/share/scripts/Form.js†L2065-L2083】

**Что делать:** передавать конфигурацию через свойства/инициализацию компонента и использовать event-bus или сервисы вместо прямых вызовов `window.parent`.

### Устаревшие API
* Для временной загрузки файлов до сих пор используется «сырой» `XMLHttpRequest`, смешанный с ручными обработчиками прогресса и статус-кодов, хотя остальная часть кода уже перешла на `fetch`. Это усложняет повторное использование логики и тестирование. 【F:engine/core/modules/share/scripts/Form.js†L1526-L1569】

**Что делать:** заменить XHR на `fetch` с `ReadableStream` или `axios`, выделить общие утилиты работы с прогрессом и обработкой ошибок, добавить retry/тайм-ауты на уровне сервиса.

## Неединый стиль и устаревшие конструкции

### Проблемы со стилем
* **Перемешивание стилей именования.** Даже в новых классах встречаются `snake_case`-поля (`quick_upload_pid`, `quick_upload_enabled`), соседствующие с `camelCase`-методами, что усложняет чтение и поиск по коду. 【F:engine/core/modules/share/scripts/AttachmentEditor.js†L25-L156】
* **Возврат к шаблону «`let t = this`».** В `DivForm` для доступа к экземпляру внутри вложенных функций заводятся временные переменные и объявляются обычные функции, вместо использования стрелочных функций или привязки контекста. Это делает код визуально устаревшим и увеличивает риск ошибок при рефакторинге. 【F:engine/core/modules/share/scripts/DivForm.js†L19-L101】
* **Ручные миксины через `Object.assign`.** После объявления класса `DivForm` к его прототипу дописываются методы из `Form.Label`, что ломает ожидание от классического наследования и затрудняет статический анализ. 【F:engine/core/modules/share/scripts/DivForm.js†L178-L184】

### Устаревшие конструкции
* **Императивные UI-сигналы через `alert`.** Валидация формы по-прежнему сообщает об ошибках стандартным всплывающим окном браузера, хотя интерфейс уже использует модальные окна и уведомления. Это создаёт разрыв в UX и блокирует внедрение единого слоя уведомлений. 【F:engine/core/modules/share/scripts/DivForm.js†L150-L175】
* **Ручная сборка DOM для индикаторов прогресса.** `AttachmentEditor` каждый раз в конструкторе создаёт и инлайново стилизует элементы прогресс-бара вместо использования компонентов или CSS-классов, что затрудняет переиспользование и темизацию. 【F:engine/core/modules/share/scripts/AttachmentEditor.js†L32-L110】
* **Повсеместный доступ к `document`/`window` без адаптеров.** Даже внутри новых классов логика тесно привязана к глобальным объектам (`document.getElementById`, `window['wysiwyg_styles']`), что мешает тестированию и серверному рендерингу. 【F:engine/core/modules/share/scripts/DivForm.js†L14-L101】【F:engine/core/modules/share/scripts/PageEditor.js†L8-L74】

### Как унифицировать стиль
1. **Закрепить соглашения ESLint/Prettier.** Включить правила на единый формат имен (`camelCase` для JS, `UPPER_CASE` для констант) и запретить временные переменные вида `const self = this` там, где доступны стрелочные функции.
2. **Вынести общие утилиты и миксины.** Методы `Form.Label` оформить как отдельный модуль и импортировать через композицию (`import { createLabelController } from ...`), чтобы избежать модификации прототипов после объявления класса.
3. **Заменить устаревшие UI-паттерны.** Использовать централизованный сервис уведомлений вместо `alert`, а для прогресс-баров — готовые компоненты или шаблоны, подключаемые через CSS.
4. **Инкапсулировать доступ к окружению.** Ввести сервис `domAdapter` с методами `queryElement`, `getConfig`, который можно мокать в тестах, и постепенно переводить компоненты на зависимость от него вместо прямого обращения к `window`/`document`.

Такой детализированный план позволит не только зафиксировать проблемные места, но и поэтапно избавляться от дублирующегося и трудно поддерживаемого JavaScript-кода.
