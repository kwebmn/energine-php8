# Анализ дублирования и сложностей поддержки JavaScript-кода

## Повторяющиеся классы модулей тестового раздела
В каталоге `engine/core/modules/auto/scripts/` присутствуют сразу три класса `Test`, `TestFeed` и `Testfeed`, которые отличаются только регистром имени и порядком вызова `getElementById`/`querySelector`, но дублируют одну и ту же логику поиска DOM-элемента, чтения атрибута `template` и экспорта с хелпером `attachToWindow`. Это классический копипаст, усложняющий любые изменения в компоненте — исправления нужно вносить синхронно в несколько файлов. 【F:engine/core/modules/auto/scripts/Test.js†L1-L26】【F:engine/core/modules/auto/scripts/TestFeed.js†L1-L26】【F:engine/core/modules/auto/scripts/Testfeed.js†L1-L26】

### Почему это проблема
* Любое изменение конструктора или экспортируемого API придётся повторять во всех трёх файлах.
* Лёгко получить рассинхронизацию — уже сейчас порядок вызова `getElementById` и `querySelector` не совпадает, что усложняет понимание, какой вариант «правильный».
* Наличие файлов, отличающихся только регистром, негативно влияет на поддержку на файловых системах без учёта регистра.

### Пошаговый план устранения
1. **Выбрать каноничное имя файла** (например, `Test.js`) и зафиксировать его в бандле/билд-скриптах.
2. **Свести расхождения конструктора** к единой версии (рекомендуется использовать `querySelector`, так как он поддерживает CSS-селекторы). Проверить, что получение `template` вынесено в одну переменную. 【F:engine/core/modules/auto/scripts/Test.js†L9-L24】
3. **Удалить дублирующие файлы** и настроить alias в require/import (если используется) — это позволит сохранить обратную совместимость при минимуме правок.
4. **Добавить unit-тест или smoke-тест для компонента** (например, инициализация с DOM fixture), чтобы зафиксировать поведение и предотвратить повторное расхождение.
5. **Автоматизировать проверку регистра имён** через линтер/скрипт в CI, чтобы новые файлы не появлялись в разных вариантах.

## Повторяемый шаблон глобального экспорта
Практически все скрипты движка содержат одинаковый шаблон объявления `const globalScope = ...` и функцию `attachToWindow`, которая навешивает класс на `window`. Примеры можно увидеть в `ModalBox`, `Toolbar`, `DivForm`, `FileRepoForm`, `AttachmentEditor` и десятках других файлов. 【F:engine/core/modules/share/scripts/ModalBox.js†L1-L68】【F:engine/core/modules/share/scripts/ModalBox.js†L556-L568】【F:engine/core/modules/share/scripts/Toolbar.js†L1-L76】【F:engine/core/modules/share/scripts/DivForm.js†L1-L103】【F:engine/core/modules/share/scripts/FileRepoForm.js†L1-L102】【F:engine/core/modules/share/scripts/AttachmentEditor.js†L1-L88】

### Почему это проблема
* Любое изменение подхода к публикации классов придётся проводить одновременно во всех файлах.
* Распыление одинакового кода затрудняет поиск реальной логики компонента — первые ~20 строк почти каждого файла заняты служебным шаблоном.
* Невозможно централизованно переопределить поведение (например, отключить автоматическое навешивание глобальных переменных) без массовой правки.

### Возможные улучшения
* Вынести логику определения `globalScope` и навешивания на `window` в общий helper и переиспользовать его.
* Рассмотреть модульную загрузку (ESM/UMD) вместо принудительного экспорта в глобальный объект.

### Как сократить количество `attachToWindow`
1. **Создать единый модуль экспорта.** Вынесите текущую функцию `attachToWindow` в новый файл (например, `engine/core/modules/share/scripts/exportToWindow.js`) и замените все локальные копии на импорт этого helper'а. Это сразу сократит количество объявлений до одного.
2. **Добавить фабрику регистрации.** Вместо ручного вызова `attachToWindow(ClassName)` в каждом модуле можно подключать новый helper, который принимает карту экспортируемых сущностей. Тогда отдельный скрипт-реестр (например, `engine/core/modules/share/scripts/bootstrap.js`) будет регистрировать их в `window`, а компонентам достаточно экспортировать свои классы.
3. **Постепенно переводить модули на ESM.** Для новых файлов используйте `export default`/`export` и подключайте их через bundler (Webpack, Rollup, Vite). Для обратной совместимости можно сохранять глобальную регистрацию только в одном месте — в сборке, которая при необходимости делает `window.ClassName = module`. По мере миграции доля ручных `attachToWindow` будет уменьшаться до нуля.

### Дополнительные меры
* **Отслеживание в статистике.** Добавьте шаг в CI, который ищет строки `attachToWindow(` и выводит их количество. Это позволит видеть динамику после каждого рефакторинга.
* **Временный polyfill.** После создания общего helper'а можно добавить предупреждение `console.warn` при прямом вызове `attachToWindow`, чтобы разработчики переходили на `registerGlobalComponent({ ... })`.
* **Документация для новых модулей.** Обновите гайдлайн по JavaScript, включив пример с импортом общего helper'а и запретом копировать шаблон `const globalScope = ...`.
* **План миграции на ESM.** Начинайте с изолированных модулей (`ModalBox`, `Toolbar`) и постепенно переносите зависимые компоненты, фиксируя список в таск-трекере, чтобы не потерять прогресс.

## Дублирование логики загрузки файлов
Компоненты управления файлами (`AttachmentEditor`, `FileRepoForm`, `FileRepository`) содержат практически идентичные реализации метода `xhrFileUpload`: настройка прогресс-бара, построение запроса `upload-temp`, обработка JSON-ответа и прогресса. Различия минимальны (дополнительные параметры `pid`). 【F:engine/core/modules/share/scripts/AttachmentEditor.js†L1-L140】【F:engine/core/modules/share/scripts/AttachmentEditor.js†L188-L228】【F:engine/core/modules/share/scripts/FileRepoForm.js†L1-L115】【F:engine/core/modules/share/scripts/FileRepoForm.js†L67-L119】【F:engine/core/modules/share/scripts/FileRepository.js†L1-L120】【F:engine/core/modules/share/scripts/FileRepository.js†L510-L596】

### Почему это проблема
* Исправление ошибок в загрузчике (например, обработка сетевых сбоев) нужно повторять в трёх местах.
* Из-за разных копий легко получить несовместимое поведение — уже сейчас один вариант принимает `pidOverride`, другой — нет.
* Тестирование усложняется: требуется гонять сценарии для каждого компонента, хотя логика одинаковая.

### Возможные улучшения
* Вынести общий загрузчик в `nativeFileHelpers.js` или отдельный модуль, а в компонентах оставлять только настройку коллбеков.
* Создать базовый класс «загрузчик с прогрессом» и переиспользовать его.

### Пошаговый план унификации
1. **Собрать отличия** (например, поддержка `pidOverride`, настройка прогресса) и оформить их как параметры/хуки общего сервиса. 【F:engine/core/modules/share/scripts/FileRepoForm.js†L67-L119】【F:engine/core/modules/share/scripts/FileRepository.js†L544-L596】
2. **Создать модуль `uploadService.js`** с функциями `createUploader(config)` и `performUpload({ endpoint, data, onProgress })`. Общие части (работа с `XMLHttpRequest`, обработка `progress`, обновление DOM) разместить внутри него. 【F:engine/core/modules/share/scripts/AttachmentEditor.js†L188-L228】
3. **Инкапсулировать связь с DOM** через интерфейсы (например, `onProgress`, `onSuccess`, `onError`), чтобы компоненты не зависели от внутренней реализации прогресс-бара.
4. **Мигрировать компоненты последовательно**, начиная с самого малого (`AttachmentEditor`), и после каждого шага запускать smoke-тест загрузки в админке.
5. **Удалить дубликаты и добавить модульные тесты** (можно мокать `XMLHttpRequest`), чтобы предотвратить повторное копирование кода.

## Большие монолитные модули

Помимо явных дублей в кодовой базе есть пласты тяжёлых монолитов, которые объединяют разнородные обязанности в одном файле.
Такие модули затрудняют точечные изменения, их невозможно загрузить частями или переиспользовать без подтягивания всего «комбайна»,
а смешение старых и новых API в одном файле усложняет миграцию.

* **`ModalBox.js`** одновременно содержит полифиллы для DOM-API, менеджер состояния модальных окон, механику фокус-трапа
  и прямое управление разметкой/стилями. Все эти задачи живут внутри одного класса на ~560 строк, и малейшее изменение
  требует прогонять весь цикл проверки, даже если нужно поправить только логику закрытия. 【F:engine/core/modules/share/scripts/ModalBox.js†L1-L200】
* **`PageEditor.js`** объединяет современную реализацию `PageEditor` с вложенным `BlockEditor`, а ниже по файлу дублирует
  легаси-версию `BlockEditor` и экспорт в глобальную область, что влечёт конфликты контекстов и двойные зависимости от CKEditor. 【F:engine/core/modules/share/scripts/PageEditor.js†L1-L310】
* **`Form.js`** и **`Toolbar.js`** (описаны ниже) демонстрируют типичную проблему сверхкрупных классов: в одном файле
  находятся как базовые контроллеры, так и вспомогательные утилиты, модальные селекторы, интеграции с внешними библиотеками
  и жёсткие связи с DOM. 【F:engine/core/modules/share/scripts/Form.js†L1-L1972】【F:engine/core/modules/share/scripts/Toolbar.js†L1-L320】

### Риски от монолитов
* **Глубокая связанность.** Внутренние методы обращаются друг к другу напрямую, поэтому невозможно заменить часть логики
  без каскадных правок по всему файлу.
* **Сложное тестирование.** Чтобы протестировать один сценарий (`focus trap` у `ModalBox`), приходится инициализировать весь
  класс со всеми зависимостями и глобальными побочными эффектами.
* **Торможение миграции.** Одновременное наличие легаси- и новой реализации (`PageEditor.BlockEditor` и глобальный `BlockEditor`)
  блокирует переход на модульный импорт: невозможно просто удалить старый код, пока он живёт в одном файле и экспортируется наружу.

### План разукрупнения
1. **Выделить слой инфраструктуры.** Создать директорию `engine/core/modules/share/scripts/components/` и перенести туда
   узкоспециализированные части (`focusTrap`, `modalLayout`, адаптеры к CKEditor). Модули должны экспортировать чистые функции
   или классы без побочных эффектов при импорте.
2. **Сформировать публичные фасады.** Для каждого крупного блока (ModalBox, PageEditor, Form, Toolbar) оставить тонкий файл,
   который собирает зависимости, но не хранит реализацию. Это позволит подключать только необходимые части при бандлинге.
3. **Развести легаси и современный API.** Унести глобальные адаптеры (`attachToWindow`, старый `BlockEditor`) в отдельные файлы
   и подключать их только в легаси-бандле. Основной код должен экспортироваться как ESM/UMD без побочных эффектов. 【F:engine/core/modules/share/scripts/PageEditor.js†L299-L310】
4. **Автоматизировать контроль размера.** Добавить в CI проверку (`eslint-plugin-perf-standard` или собственный скрипт), которая
   падает, если файл превышает заданный порог строк (например, 400). Это поможет удержать новые модули от повторного разрастания.

## Монолитный класс формы
`engine/core/modules/share/scripts/Form.js` содержит 2119 строк и совмещает в себе десятки разных обязанностей: управление вкладками, загрузку файлов, инициализацию CKEditor, работу с «богатыми» редакторами, селекторы sitemap и т.д. В файле объявлены и основная форма, и вложенные классы (`Form.Uploader`, `Form.SmapSelector`, `Form.AttachmentSelector` и др.), причём каждая сущность реализует собственную сложную логику в рамках одного файла. 【F:engine/core/modules/share/scripts/Form.js†L1-L120】【F:engine/core/modules/share/scripts/Form.js†L1680-L1760】【F:engine/core/modules/share/scripts/Form.js†L1743-L1794】【F:engine/core/modules/share/scripts/Form.js†L1795-L1880】【F:engine/core/modules/share/scripts/Form.js†L1881-L1972】

### Почему это проблема
* Из-за объёма файла сложно найти нужный участок и отследить зависимости между вложенными классами.
* Любые изменения требуют перепроверять большое количество неочевидных связей — например, `Form.Uploader` напрямую модифицирует DOM, а `Form.SmapSelector` открывает модальные окна, что затрудняет unit-тестирование.
* Совмещены как базовые API-методы, так и UI-утилиты (иконки предпросмотра, работа с Cookie), что затрудняет переиспользование.

### Возможные улучшения
* Разделить файл на модули: основной контроллер формы, отдельные классы для загрузчика, селекторов, работы с preview.
* Инкапсулировать работу с DOM и внешними библиотеками в отдельные сервисы или адаптеры.

### Рекомендованная декомпозиция
1. **CoreForm** — класс, отвечающий только за жизненный цикл формы, валидацию и переключение вкладок. Код конструктора инициализации контролов (строки 315–420) переместить сюда. 【F:engine/core/modules/share/scripts/Form.js†L315-L420】
2. **FormUploadService** — вынести логику `Form.Uploader` в отдельный файл с чётким API (`init`, `upload`, `reset`). 【F:engine/core/modules/share/scripts/Form.js†L1670-L1745】
3. **ModalSelectors** — оформить `Form.SmapSelector` и `Form.AttachmentSelector` в модуль с единым интерфейсом `openSelector`. Это позволит переиспользовать модальные окна вне формы. 【F:engine/core/modules/share/scripts/Form.js†L1747-L1872】
4. **Adapters для сторонних библиотек** — создать обёртки `ckeditorAdapter.js`, `codeMirrorAdapter.js`, которые будут отвечать за подключение редакторов (строки 352–372). 【F:engine/core/modules/share/scripts/Form.js†L352-L372】
5. **Отдельные entry-пойнты** — разбить `Form.js` на пакет модулей и собрать их через bundler, что сократит время загрузки и облегчит тестирование.

## Крупный класс панели инструментов
`engine/core/modules/share/scripts/Toolbar.js` содержит 860 строк и описывает сразу несколько типов контролов (кнопки, выпадающие меню, группы), управляет DOM-структурами, состоянием и событиями. Всё это находится в одном классе, а вспомогательные подклассы объявлены непосредственно внутри файла. 【F:engine/core/modules/share/scripts/Toolbar.js†L1-L120】【F:engine/core/modules/share/scripts/Toolbar.js†L121-L220】【F:engine/core/modules/share/scripts/Toolbar.js†L221-L320】

### Почему это проблема
* В отсутствие явного разделения по файлам трудно переиспользовать отдельные контролы или протестировать их изоляционно.
* Изменение API одного подкласса легко ломает остальные, потому что они зависят от общих приватных соглашений (например, структуры `this.controls`).
* Такой файл тяжело грузить постепенно — любой импорт подтянет весь объём кода, даже если нужен один тип кнопки.

### Возможные улучшения
* Разбить компоненты панели на отдельные модули/классы и оставить в `Toolbar` только сборку и управление контейнером.
* Добавить фабрики или реестр контролов вместо жёстких `switch`.

### Предлагаемый рефакторинг
1. **Выделить базовую сущность `ToolbarControl`** (уже присутствует как вложенный класс) в отдельный файл и подключать через `import`. Это позволит создавать дополнительные контролы без изменения основного класса. 【F:engine/core/modules/share/scripts/Toolbar.js†L168-L220】
2. **Создать реестр контролов**: объект `controlRegistry`, где ключ — `type`, а значение — класс. Тогда метод `appendControl` сможет запрашивать контрол через `registry.get(type)` вместо `switch`. 【F:engine/core/modules/share/scripts/Toolbar.js†L20-L75】
3. **Разделить ответственность за Bootstrap-интеграцию**: вынести проверки `hasBootstrapStyles/Script` и методы `createBootstrapTooltip/Dropdown` в модуль `toolbarBootstrap.js`. 【F:engine/core/modules/share/scripts/Toolbar.js†L128-L164】
4. **Добавить тесты на фабрику** — простая проверка, что JSON-описание тулбара с разными типами контролов собирается корректно, поможет фиксировать API и сократит риск регрессий.

## Фрагменты, не используемые в новой логике

Несмотря на внедрение обновлённых классов и сервисов, в репозитории остаются участки кода, которые больше не задействованы в актуальных сценариях, но продолжают подгружаться из легаси-бандлов. Они увеличивают объём загрузки и затрудняют понимание, какой API считается каноническим.

### Примеры оставшихся фрагментов
* **Дублирующий `BlockEditor` в `PageEditor.js`.** Новый редактор инициализирует инлайн-редакторы через статическое вложение
  `PageEditor.BlockEditor`, использующее `fetch` и промисы, однако ниже по файлу всё ещё лежит старая реализация класса
  `BlockEditor`, сохраняющая данные через `Energine.request`. Она экспортируется ради обратной совместимости и навешивается на
  `window`, хотя современный код до неё не доходит. 【F:engine/core/modules/share/scripts/PageEditor.js†L26-L150】【F:engine/core/modules/share/scripts/PageEditor.js†L159-L306】
* **Заглушки для jQuery и jsTree.** Файлы `jquery.min.js` и `jstree/jstree.js` больше не содержат библиотек — это лишь проверка, что
  сборка Vite заранее положила реальные пакеты в `window`. Новая логика импортирует зависимости напрямую, поэтому эти заглушки
  служат только для старого debug-режима. 【F:engine/core/modules/share/scripts/jquery.min.js†L1-L22】【F:engine/core/modules/share/scripts/jstree/jstree.js†L1-L24】
* **Неприменяемые хелперы PageToolbar.** Класс `PageToolbar` оставляет методы `_collectBreadcrumbs` и `_extractBreadcrumbTrail`,
  но современная вёрстка панели не вызывает их, из-за чего функция не участвует в построении интерфейса и только поддерживает
  прошлые макеты. 【F:engine/core/modules/share/scripts/PageToolbar.js†L573-L611】

### Как безопасно удалить или законсервировать
1. **Собрать статистику использования.** Добавить инструмент в CI, который ищет обращения к глобальным `PageEditor.BlockEditor` и
   трекам `jquery.min.js`/`jstree.js` в шаблонах. Отчёт покажет, остаются ли страницы, где они реально нужны.
2. **Вынести заглушки в легаси-бандл.** Вместо публикации в основном бандле подключить их только на страницах со старым лоадером
   (например, через условный импорт в PHP-шаблоне). Это предотвратит случайное использование и ускорит современные страницы.
3. **Документировать план удаления.** Для каждой заглушки завести задачу: определить крайний срок, когда модуль можно удалить, и
   назначить ответственного. В документации указать замену (например, импорт `PageEditor` как ESM).
4. **Автоматизировать проверку актуальности.** В линтере или unit-тестах добавить проверки, что новые модули не импортируют
   старые заглушки, а при отсутствии вызовов `_extractBreadcrumbTrail` тест сигнализирует о возможности удаления.

## Закомментированный код и артефакты миграции

При переходе от глобальных скриптов к модульной структуре в репозитории накопились участки кода, которые оставлены закомментированными «на всякий случай» или служат временными мостами между старым и новым API. Они не исполняются, но продолжают жить в файлах, затрудняя анализ и маскируя реальные зависимости.

### Где проявляется
* **`Form.js`** хранит отключённый вызов `Overlay` и дублирующее присваивание `componentElement`, оставшиеся после адаптации конструктора под новые селекторы. 【F:engine/core/modules/share/scripts/Form.js†L315-L356】
* **`PageEditor.js`** содержит сразу две копии обработчиков CKEditor: новая версия с `fetch` и старая с `Energine.request`, между которыми разбросаны закомментированные вызовы `overlay` и события `blur/focus`. Это напрямую сигнализирует о незавершённой миграции редактора. 【F:engine/core/modules/share/scripts/PageEditor.js†L90-L150】【F:engine/core/modules/share/scripts/PageEditor.js†L224-L241】
* **`GridManager.js`** совмещает классическую реализацию `Grid`, более современный `GridManager`, закомментированные варианты `export default` и даже полностью отключённый расчёт `ScrollBarWidth`, который оставлен как «шпаргалка» на случай отката. 【F:engine/core/modules/share/scripts/GridManager.js†L1370-L2070】【F:engine/core/modules/share/scripts/GridManager.js†L2448-L2508】

### Почему это опасно
* **Ложное ощущение поддержки.** Разработчики видят закомментированный код и предполагают, что его можно быстро «вернуть», хотя зависимости уже не собираются, что ведёт к ошибкам при попытке восстановить блок.
* **Рост когнитивной нагрузки.** Чтобы разобраться, какая версия логики активна, приходится читать весь файл и отслеживать, что закомментировано, а что реально выполняется.
* **Торможение миграции.** Пока мосты и отключённые фрагменты присутствуют, сложно удалить старые API: всегда есть соблазн полагаться на них вместо завершения перехода.

### Как навести порядок
1. **Провести аудит «мертвого» кода.** Для каждого закомментированного блока определить владельца и срок, после которого фрагмент удаляется или переносится в сниппет-документацию (если действительно нужен как пример).
2. **Сделать fallback'и явными.** Если функциональность действительно нужна (например, расчёт `ScrollBarWidth`), оформить её как утилиту с флагом включения, а не оставлять в комментариях без тестов.
3. **Завершить миграцию и удалить мосты.** После переноса модулей на ESM убрать закомментированные `attachToWindow`, дубли `Grid`/`GridManager` и старые вызовы `Energine.request`, зафиксировав изменения в changelog.
4. **Добавить линтер для поиска закомментированного кода.** Простейший скрипт, ищущий паттерны `//this.` или многострочные блоки с `Energine.request` внутри комментариев, поможет контролировать, чтобы новые «временные» вставки не появлялись.

## Общий план внедрения

1. **Приоритизация**: начать с устранения дублирующих файлов (`Test*`) и унификации `attachToWindow`, потому что эти задачи затрагивают десятки модулей и сразу уменьшают технический долг.
2. **Создание вспомогательных пакетов**: подготовить директорию `engine/core/modules/share/scripts/helpers/` для общих сервисов (глобальный экспорт, загрузка файлов, адаптеры к библиотекам) и вынести туда код из монолитов.
3. **Постепенная миграция**: после появления общих helper'ов переносить по 2–3 компонента за итерацию, фиксируя прогресс в таблице (сколько файлов ещё содержит `attachToWindow`, сколько — старый шаблон загрузки).
4. **Инструменты контроля качества**: добавить линтер (ESLint) с правилами против глобальных синглтонов и копипаста, включить `eslint-plugin-you-dont-need-lodash-underscore` и `eslint-plugin-import` для контроля зависимостей.
5. **Документация и обучение**: провести внутренний воркшоп/демо по новым helper'ам и процессу миграции, чтобы команда использовала обновлённый подход при разработке новых модулей.

## Глобальные зависимости и устаревшие подходы

### Глобальный мост Energine
* `Energine.js` инициализирует прокси-мост, привязывает рантайм к `window` и копирует утилиты (`safeConsoleError`, `showLoader`, `hideLoader`) в глобальную область видимости. Из-за этого компонентам сложнее работать изолированно, а тестам — подменять окружение без реального `window`. 【F:engine/core/modules/share/scripts/Energine.js†L1-L167】【F:engine/core/modules/share/scripts/Energine.js†L827-L837】
* Мост подтягивает существующую конфигурацию из `window.Energine`, что делает порядок загрузки критичным: любые расхождения в инициализации приводят к тому, что компоненты читают устаревшие значения. 【F:engine/core/modules/share/scripts/Energine.js†L841-L858】

**Что делать:** зафиксировать явный `bootEnergine(config)` как единственную точку входа, отдавать рантайм через экспорты и DI, а глобальную регистрацию выполнять только в легаси-адаптере. Для тестов обеспечить фабрику, создающую экземпляр без доступа к `window`.

### Требование глобальных библиотек
* `TemplateWizard` напрямую ожидает, что `jQuery` уже записан в `window`, и падает, если библиотека не найдена. Это затрудняет код-сплиттинг и любые попытки перехода на чистый ES-модульный стек. 【F:engine/core/modules/wizard/scripts/TemplateWizard.js†L5-L50】
* `Toolbar` проверяет наличие `window.bootstrap` и обращается к глобальному объекту `bootstrap.*` вместо модульного импорта, из-за чего нельзя гибко обновлять версию Bootstrap и подключать только нужные компоненты. 【F:engine/core/modules/share/scripts/Toolbar.js†L1-L164】
* Загрузчик CKEditor самостоятельно создаёт `<script>` в `document.head`, выставляет `window.CKEDITOR_BASEPATH` и ожидает появление глобального `window.CKEDITOR`. Любые попытки пакетировать редактор вместе с приложением усложняются этими сайд-эффектами. 【F:engine/core/modules/share/scripts/ckeditor/loader.js†L1-L48】

**Что делать:** обернуть внешние библиотеки в адаптеры с явными импортами, перевести зависимости на lazy-import (`import()`), а старый глобальный API поддерживать через шим, который подключается только в легаси-страницах.

## Глобальные экспортные функции

Помимо прямого доступа к зависимостям через `window`, большинство модулей публикуют себя в глобальном пространстве имён через однотипные функции `attachToWindow`. Каждая из них повторяет присвоение класса на объект `window` и выполняет его сразу после определения, что влечёт скрытые сайд-эффекты и мешает модульному подключению. Примеры можно увидеть в `ModalBox`, `Toolbar` и `Form`, а «ядро» Energine через собственный метод `attachToWindow` экспортирует мостовые утилиты (`safeConsoleError`, `showLoader`, `hideLoader`) глобально. 【F:engine/core/modules/share/scripts/ModalBox.js†L543-L568】【F:engine/core/modules/share/scripts/Toolbar.js†L848-L860】【F:engine/core/modules/share/scripts/Form.js†L2104-L2119】【F:engine/core/modules/share/scripts/Energine.js†L827-L882】

### Почему это опасно
* **Трудно отслеживать коллизии имён.** Две разные версии компонента могут записать себя в одну и ту же глобальную переменную, и последний выполненный бандл «победит» без предупреждений.
* **Порядок загрузки критичен.** Поскольку `attachToWindow()` вызывается немедленно, подключение модулей вне основного бандла (например, через dynamic import) может перезаписать уже инициализированные зависимости.
* **Сложно тестировать и внедрять DI.** Юнит-тестам приходится мокеить `window`, а подмена зависимостей (например, другой реализации `ModalBox`) требует менять глобальный объект, а не импорт.

### Как можно улучшить
1. **Централизовать регистрацию.** Оставить единственный helper (например, `registerGlobalComponent(name, value)`), который вызывается из бандла, а не из каждого модуля. Так можно логировать переопределения и контролировать порядок загрузки.
2. **Хранить экспорт в реестре.** Вместо прямых присвоений формировать карту `globals` и публиковать её одной операцией, что упрощает миграцию на модульную схему и позволяет отключать ненужные сущности на новых страницах.
3. **Предусмотреть «легаси-адаптер».** Современные файлы оставляют только ESM-экспорт, а отдельный адаптер (например, `legacy-window-bridge.js`) подхватывает класс и решает, писать ли его в `window`. Это позволяет постепенно отказаться от глобальных экспортов без риска для старых страниц.

### Глобальные конфигурации и обращения к `window`
* `Form` вешает обработчики на `window` и `window.parent.ModalBox`, что требует наличия полноценного DOM и сложной структуры фреймов даже при тестировании отдельных методов. 【F:engine/core/modules/share/scripts/Form.js†L425-L435】
* Для настройки стилей редактора форма ожидает массив `wysiwyg_styles` в глобальной области. Такой контракт не документирован и затрудняет перенос данных в модульные конфиги. 【F:engine/core/modules/share/scripts/Form.js†L2065-L2083】

**Что делать:** передавать конфигурацию через свойства/инициализацию компонента и использовать event-bus или сервисы вместо прямых вызовов `window.parent`.

### Устаревшие API
* Для временной загрузки файлов до сих пор используется «сырой» `XMLHttpRequest`, смешанный с ручными обработчиками прогресса и статус-кодов, хотя остальная часть кода уже перешла на `fetch`. Это усложняет повторное использование логики и тестирование. 【F:engine/core/modules/share/scripts/Form.js†L1526-L1569】

**Что делать:** заменить XHR на `fetch` с `ReadableStream` или `axios`, выделить общие утилиты работы с прогрессом и обработкой ошибок, добавить retry/тайм-ауты на уровне сервиса.

## Неединый стиль и устаревшие конструкции

### Проблемы со стилем
* **Перемешивание стилей именования.** Даже в новых классах встречаются `snake_case`-поля (`quick_upload_pid`, `quick_upload_enabled`), соседствующие с `camelCase`-методами, что усложняет чтение и поиск по коду. 【F:engine/core/modules/share/scripts/AttachmentEditor.js†L25-L156】
* **Возврат к шаблону «`let t = this`».** В `DivForm` для доступа к экземпляру внутри вложенных функций заводятся временные переменные и объявляются обычные функции, вместо использования стрелочных функций или привязки контекста. Это делает код визуально устаревшим и увеличивает риск ошибок при рефакторинге. 【F:engine/core/modules/share/scripts/DivForm.js†L19-L101】
* **Ручные миксины через `Object.assign`.** После объявления класса `DivForm` к его прототипу дописываются методы из `Form.Label`, что ломает ожидание от классического наследования и затрудняет статический анализ. 【F:engine/core/modules/share/scripts/DivForm.js†L178-L184】

### Устаревшие конструкции
* **Императивные UI-сигналы через `alert`.** Валидация формы по-прежнему сообщает об ошибках стандартным всплывающим окном браузера, хотя интерфейс уже использует модальные окна и уведомления. Это создаёт разрыв в UX и блокирует внедрение единого слоя уведомлений. 【F:engine/core/modules/share/scripts/DivForm.js†L150-L175】
* **Ручная сборка DOM для индикаторов прогресса.** `AttachmentEditor` каждый раз в конструкторе создаёт и инлайново стилизует элементы прогресс-бара вместо использования компонентов или CSS-классов, что затрудняет переиспользование и темизацию. 【F:engine/core/modules/share/scripts/AttachmentEditor.js†L32-L110】
* **Повсеместный доступ к `document`/`window` без адаптеров.** Даже внутри новых классов логика тесно привязана к глобальным объектам (`document.getElementById`, `window['wysiwyg_styles']`), что мешает тестированию и серверному рендерингу. 【F:engine/core/modules/share/scripts/DivForm.js†L14-L101】【F:engine/core/modules/share/scripts/PageEditor.js†L8-L74】

### Как унифицировать стиль
1. **Закрепить соглашения ESLint/Prettier.** Включить правила на единый формат имен (`camelCase` для JS, `UPPER_CASE` для констант) и запретить временные переменные вида `const self = this` там, где доступны стрелочные функции.
2. **Вынести общие утилиты и миксины.** Методы `Form.Label` оформить как отдельный модуль и импортировать через композицию (`import { createLabelController } from ...`), чтобы избежать модификации прототипов после объявления класса.
3. **Заменить устаревшие UI-паттерны.** Использовать централизованный сервис уведомлений вместо `alert`, а для прогресс-баров — готовые компоненты или шаблоны, подключаемые через CSS.
4. **Инкапсулировать доступ к окружению.** Ввести сервис `domAdapter` с методами `queryElement`, `getConfig`, который можно мокать в тестах, и постепенно переводить компоненты на зависимость от него вместо прямого обращения к `window`/`document`.

Такой детализированный план позволит не только зафиксировать проблемные места, но и поэтапно избавляться от дублирующегося и трудно поддерживаемого JavaScript-кода.
