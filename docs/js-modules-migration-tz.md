# Техническое задание: миграция JS-кода Energine на ES-модули

## Общие положения
- **Цель**: перевести все внутренние JavaScript-скрипты Energine из формата глобальных `<script>` в полноценные ES-модули (import/export), обеспечить корректное подключение и инициализацию функциональности без опоры на порядок загрузки.
- **Окружение**: современный браузерный стек с нативной поддержкой ES-модулей. Поддержка устаревших браузеров (включая IE11) не требуется; целевая версия языка — не ниже ES2022.
- **Ограничения**: внешние библиотеки (jQuery, CKEditor и др.) остаются подключёнными как обычные глобальные скрипты.
- **Предпосылки**: у проекта есть резервная копия. Изменения внедряются сразу без режима совместимости и без дублирования скриптов.
- **Принцип миграции**: обеспечить работу проекта на ES6-модулях с минимальными переделками — без переработки архитектуры подключений и без введения дополнительных точек входа.

## Фаза 1. Подготовка и аудит
1. **Сформировать каталог скриптов**
   - Пройти по каталогам `engine/*/modules/scripts/` и `site/default/modules/scripts/`, зафиксировать список всех JS-файлов, а также дополнительные директории со скриптами (если есть).
   - Создать таблицу зависимостей: для каждого файла указать, какие глобальные объекты/функции он использует и кто их предоставляет.
2. **Зафиксировать подключаемые файлы**
   - Для каждой страницы/компонента определить набор модулей, которые должны быть инициализированы.
   - Зафиксировать текущий порядок подключения `<script>` в шаблонах PHP/XSLT и в механизмах, формирующих страницу.
3. **Уточнить требования к глобальному API**
   - Выявить функции/классы, которые должны оставаться доступными из глобального пространства (`window`).
   - Зафиксировать сценарии использования из HTML-атрибутов (например, `onclick="..."`).
4. **Подготовить инфраструктуру**
   - Убедиться, что сервер отдаёт файлы `.js` с MIME `text/javascript` (для `.mjs` использовать аналогичный тип).
   - Настроить линтер/форматирование для единого стиля (опционально, если уже используется ESLint/Prettier).

## Фаза 2. Проектирование новой структуры
1. **Определить стратегию модульности**
   - Подтвердить сохранение текущей схемы «один файл — один тег `<script>`» для каждой страницы. Для каждого подключаемого файла прописать, что он будет переведён в модуль без изменения текущей структуры подключений.
   - Зафиксировать правила именования файлов, директорий и экспортируемых сущностей, не нарушая текущую файловую иерархию.
2. **Уточнить ядро приложения**
   - Определить существующие базовые файлы, предоставляющие общие объекты (например, `Energine.js`, `EnergineApp`, утилиты), и перевести их на экспортируемые сущности.
   - Для `Energine.js` подготовить схему экспорта ядра инициализации (см. Фазу 3) так, чтобы модуль предоставлял:
     - именованные экспорты с константами/вспомогательными функциями;
     - экспорт по умолчанию с классом/функцией запуска (если требуется);
     - автоматическое закрепление API в `window`, которое выполняется внутри самого файла и не требует внешних вызовов.
   - Обозначить, какие элементы из ядра должны экспортироваться по умолчанию, а какие — поименованно, не меняя их расположение.
3. **Определить схему импорта внешних глобальных библиотек**
   - Описать, какие глобальные переменные (например, `window.jQuery`) будут явно проксироваться в модули.
   - Зафиксировать подход к инициализации CKEditor и других библиотек (например, экспорт обёртки `initCKEditor()` из отдельного модуля).

## Фаза 3. Миграция скриптов на ES-модули
1. **Общая методология**
   - Для каждого файла заменить конструкцию самовызывающихся функций/глобальных присваиваний на явные экспортируемые сущности (`export`, `export default`).
   - В местах использования глобальных переменных заменить обращения на импорты (`import { ... } from '...';`).
   - Удалить неиспользуемые глобальные объявления.
   - Минимизировать переразбиение файлов: все изменения должны укладываться в существующие файлы, чтобы сохранить структуру проекта и упростить код-ревью.
2. **Работа с зависимостями**
   - На основании аудита прописать `import`-директивы в начале файлов.
   - Если возникает циклическая зависимость, реорганизовать код (объединить модули или выделить общие части).
3. **Инициализационный код**
   - Вынести запуск логики в функции/классы, экспортируемые из модулей.
   - Сохранить существующую логику инициализации, завязанную на отдельные файлы. Если страница сейчас подключает несколько `<script>`, каждый из них остаётся самостоятельным модулем и инициализируется в рамках своего файла.
   - Для `Energine.js` реализовать явный экспорт стартовой функции (например, `bootEnergine(config)`), которая возвращает/обновляет объект Energine. Внутри файла оставить автоинициализацию: модуль должен импортировать конфигурацию (см. шаг ниже), вызвать `bootEnergine()` и при необходимости закрепить результат в `window.Energine`.
   - Подготовить вспомогательный экспорт (например, `createConfigFromProps(props)`) для потребления данных из XSLT-шаблонов. Это позволит `START_ENERGINE_JS` собрать объект конфигурации и передать его в `bootEnergine()` без ручного формирования глобальной переменной.
   - При необходимости добавить в модуль явную функцию `init()` и вызывать её внутри того же файла, чтобы не требовать переработки шаблонов.
   - Зафиксировать, что `START_ENERGINE_JS` (см. XSLT-шаблоны) использует импортируемую функцию конфигурации и не зависит от глобальных побочных эффектов.
4. **Работа с глобальным API**
   - Если требуется оставить глобальный доступ, выполнить явное присваивание в `window` из модуля, например:
     ```js
     import { FormManager } from './FormManager.js';
     window.Energine = { ...window.Energine, FormManager };
     ```
   - По возможности минимизировать количество таких присваиваний.
5. **Обновление путей и расширений**
   - Сохранить расширение `.js` (если не требуется `.mjs`).
   - При необходимости изменить относительные пути в импортах (`../` и т.д.).

## Фаза 4. Адаптация серверной части и шаблонов
1. **Обновление механизма подключения скриптов**
   - Найти все места, где формируются `<script>` для внутренних модулей (PHP, XSLT, конфиги) и заменить их на `<script type="module" src="..."></script>`.
   - Сохранить текущую последовательность подключения скриптов: до будущей реорганизации каждая страница продолжает выводить те же файлы по отдельности, чтобы гарантировать минимальные изменения.
2. **Обновление шаблонов и компонент**
   - В шаблонах, где JS инициализируется через inline-скрипты, заменить вызовы на импортируемые функции/методы.
   - Для динамических вставок (AJAX) удостовериться, что повторная инициализация происходит через модульные функции.
3. **Поддержка внешних библиотек**
   - Убедиться, что `<script>`-теги для jQuery/CKEditor остаются без `type="module"` и подключаются до модульных скриптов.
   - При необходимости обернуть обращения к ним в отдельные модули-адаптеры.
4. **Шаблоны `document.xslt` и `energine.xslt`**
   - В `engine/core/modules/share/transformers/bootstrap/document.xslt` и `site/modules/default/transformers/energine.xslt` обновить блоки, отвечающие за старт платформы:
     - заменить `<script type="text/javascript" src="{$STATIC_URL}scripts/Energine.js"></script>` на модульный аналог (атрибут `type="module"` с сохранением текущего `src`).
     - скорректировать шаблон `START_ENERGINE_JS`, чтобы он генерировал **модульный** inline-скрипт: `import { bootEnergine } from '{$STATIC_URL}scripts/Energine.js';` → сбор конфигурации из XSLT-переменных → вызов `bootEnergine(config)`.
     - полагаться на то, что модуль самостоятельно закрепляет `window.Energine` при загрузке; дополнительных вызовов из шаблонов не требуется.
   - Дополнить шаблоны комментариями о том, что все дальнейшие скрипты должны ожидать готового `bootEnergine()` и импортировать его при необходимости.
   - Проверить, что `energine.xslt` по-прежнему вызывает `START_ENERGINE_JS` и загружает модульные скрипты в прежней последовательности, но уже с `type="module"`.
   - Перенести все инлайновые обращения к глобальному `Energine` в отдельные модульные функции (при необходимости — в `Energine.js`), а в XSLT оставлять только вызовы экспортируемых API.

## Фаза 5. Обновление конфигураций и вспомогательных инструментов
1. **Конфигурационные файлы**
   - Проверить конфиги, где перечисляются скрипты модулей (если такие существуют), и обновить пути/имена файлов.
   - Сохранить конфигурацию списков файлов; корректировка сводится к добавлению атрибута `type="module"` при генерации HTML и актуализации путей импортов внутри самих файлов.
2. **Build/Deploy скрипты**
   - Обновить сценарии сборки/развёртывания, чтобы они учитывали новые файлы.
   - При необходимости добавить шаг проверки синтаксиса ES-модулей (например, `npm run lint`).

## Фаза 6. Тестирование
1. **Функциональное тестирование**
   - Проверить работу всех страниц и компонентов, ранее использовавших модули: формы, сетки, виджеты, редактор контента и т.д.
   - Убедиться в отсутствии ошибок в консоли браузера (особенно `ReferenceError` из-за неинициализированных зависимостей).
2. **Производительность**
   - Измерить основные метрики (Time to Interactive, загрузка JS) через Lighthouse/PageSpeed до и после миграции.
3. **Регрессионные тесты**
   - Выполнить имеющиеся автотесты (если есть) или smoke-тесты по ключевым сценариям.

## Фаза 7. Документация и поддержка
1. **Обновить проектную документацию**
   - Зафиксировать новую структуру модулей, правила импорта и соответствие между страницами и подключаемыми файлами в отдельном документе для разработчиков.
   - Добавить отдельный раздел о `Energine.js`: описать его экспортируемые API, порядок конфигурирования (через `START_ENERGINE_JS`) и требования к скриптам, которые рассчитывают на глобальный объект.
2. **Переобучить команду**
   - Подготовить краткое руководство о работе с ES-модулями внутри Energine (шаблон для новых модулей, пример интеграции с PHP-шаблонами).
3. **План дальнейшей интеграции с Vite**
   - На основе выполненной миграции описать шаги подключения Vite (dev-сервер, production build) — в виде roadmap.

## Контрольные точки
- ✅ Завершён аудит и карта зависимостей.
- ✅ Все существующие скрипты переведены на модульный формат без изменения схемы подключений.
- ✅ Все зависимости описаны через `import`/`export`, отсутствуют неявные обращения к глобальным переменным.
- ✅ Обновлены шаблоны и конфиги для `<script type="module">`.
- ✅ Пройдены функциональные и регрессионные тесты без критичных ошибок.
- ✅ Обновлена документация и план внедрения Vite.

