# Переводы и порядок инициализации (Фаза 3.3)

## 1. Цель и границы

Задача: гарантировать, что клиентские компоненты Energine получают локализованные строки
до вызова их конструкторов, независимо от режима (`debug=1` или `debug=0`). Спецификация
опирается на существующую модель данных переводов (XML-узлы `<document/translations>` и
серверную подготовку словарей) и дополняет единый лоадер (Фаза 3.2) требованиями к
порядку загрузки и проверкам готовности.

## 2. Источники данных переводов

1. **Основной транспорт** — XML-секция `<document/translations>` формируется PHP-движком
   (`Document::buildTranslations()`). В XSLT она сериализуется в DOM:
   - либо как `<script type="application/json" data-energine-translations>` c текстовым
     JSON-фрагментом (предпочтительный формат для новых шаблонов);
   - либо как набор `<script>window.Energine.translations.extend(...)</script>` (legacy).
2. Дополнительные наборы (например, для отдельных тулбаров или диалогов) размещаются
   рядом с компонентами внутри контейнеров `<div data-energine-translations-def="key">`
   с вложенными `<span data-key>`.
3. Внешние библиотеки (CKEditor, jsTree и др.) поставляют собственные языковые пакеты
   через свои механизмы. Они должны быть загружены до старта компонентов, которые их
   требуют, но их загрузка контролируется политиками Phase 2 (dev/prod поставка).

## 3. Требования к расположению и времени доступности

1. Переводы для страницы должны быть встроены в HTML **до** закрывающего `</body>` и
   находиться в DOM уже к моменту наступления `DOMContentLoaded`.
2. Лоадер читает глобальный словарь из элемента `data-energine-translations` в `<head>` или
   начале `<body>`. Для совместимости допускается чтение legacy-инлайна: лоадер проверяет
   наличие `window.Energine.translations` и инициализирует runtime-хранилище, если JSON-блок
   отсутствует.
3. Компонентные словари (`data-energine-translations-def`) должны лежать в том же DOM
   поддереве, что и целевой компонент, чтобы Ajax-догрузка могла скопировать их вместе с
   шаблоном.

## 4. Последовательность действий лоадера

1. `loader.bootstrap()` вызывает `ensureTranslationsReady()` перед сканированием DOM:
   - ищем `<script[data-energine-translations]>`; если найден, парсим содержимое (XML-safe
     текст без CDATA) в объект `Energine.translations`;
   - если отсутствует, проверяем `window.Energine.translations` (legacy). При отсутствии обоих
     источников — логируем предупреждение и создаём пустой объект.
2. После чтения глобального словаря лоадер помечает состояние `translationsReady = true`.
3. При обходе элементов лоадер извлекает локальные словари:
   - `data-energine-translations="key"` на компоненте → ищем блок определения
     `data-energine-translations-def="key"`, парсим дочерние элементы (`data-key="..."`),
     формируем объект `translations[key]` и передаём в `params.translations`.
   - Если блок не найден — логируем предупреждение и продолжаем без локальных строк.
4. Перед созданием экземпляра компоненту передаётся `params.translations` (объединение
   глобальных и локальных строк). Компонент может дополнительно запросить `Energine.i18n`
   для ленивой загрузки.

## 5. Проверки готовности и порядок выполнения

1. Лоадер не должен запускать `scan()` до тех пор, пока `ensureTranslationsReady()` не
   подтвердит наличие глобального словаря.
2. Если JSON-блок обнаружен, но парсинг завершился ошибкой (невалидный формат, XSLT
   испортила escaping), лоадер фиксирует ошибку (`console.error`) и продолжает работу с
   пустым словарём. Это позволяет страницам оставаться рабочими, но сигнализирует о
   проблеме.
3. Компоненты, которые критично зависят от переводов (например, тулбары), должны проверять
   наличие требуемых ключей и, при отсутствии, отображать fallback-тексты; лоадер не должен
   останавливать запуск.
4. Для Ajax-догрузки фрагментов `ensureTranslationsReady()` вызывается повторно: если в
   поддереве присутствуют новые `data-energine-translations` блоки, они мерджатся в
   глобальное хранилище перед инициализацией компонентов в этом фрагменте.

## 6. Чек-лист при внедрении

- [ ] В XSLT-шаблонах передано `data-energine-translations` (JSON или legacy) до `</body>`.
- [ ] Все компоненты с локальными словарями содержат связанный `data-energine-translations-def`.
- [ ] Лоадер парсит глобальные переводы до вызова `scan()` (см. unit-tests/интеграционные
      проверки при реализации).
- [ ] На страницах без переводов лоадер логирует предупреждение только в debug-режиме.
- [ ] Ajax-контейнеры доставляют локальные словари вместе с HTML-фрагментом и повторный
      вызов `scan()` корректно пополняет `Energine.translations`.

## 7. Результат

При соблюдении регламента любые компоненты Energine получают доступ к актуальным
переводам до старта конструктора, независимо от режима сборки и способа загрузки страницы.
