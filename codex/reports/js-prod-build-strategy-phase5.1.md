# Стратегия production-сборки (Phase 5.1, Vite)

## 1. Цель и предпосылки

- Подготовить production-бандлы Energine без dev-сервера.
- Сохранить текущие позиции `<script>` в XSLT, подменив пути на собранные файлы из `/assets`.
- Минимизировать число HTTP-запросов: публичные страницы получают `site`-бандл, админка — `admin` (при необходимости — плюс `site`).
- Использовать правила Phase 4.1 для включения внешних библиотек в сборку.

## 2. Точки входа

| Entry | Область | Предполагаемый исходник | Примечания |
|-------|---------|-------------------------|------------|
| `site` | Публичные страницы | `assets/js/site-entry.js` | Импортирует общий рантайм, компоненты публичной части, загрузчик переводов. |
| `admin` | Админка (и общие модули, используемые в админке) | `assets/js/admin-entry.js` | Импортирует всё, что нужно админке; при необходимости явно подтягивает публичные компоненты. |

*Каждая точка входа должна инициализировать единый лоадер Phase 3.2 после готовности переводов (Phase 3.3).* Общие модули можно переиспользовать через явные импорт/экспорт, чтобы избежать дублирования.

## 3. Директория вывода и выпуск артефактов

- `build.outDir = "assets"` в `vite.config.js`, чтобы все файлы попадали прямо в `/assets` (относительно веб-корня).
- Перед сборкой каталог очищается от старых хешированных файлов.
- Деплой копирует `/assets` без дополнительного вложения каталогов.

## 4. Именование файлов и хеширование

- Включить хеши в имени (`build.rollupOptions.output.entryFileNames = "[name].[hash].js"`, аналогично для CSS через `assetFileNames`).
- Ожидаемые имена: `site.<hash>.js`, `admin.<hash>.js`, при наличии CSS — `site.<hash>.css`, `admin.<hash>.css`.
- Общие vendor-чанки именуются `vendor-<hash>.js`.
- Генерировать `manifest.json`, чтобы PHP мог находить актуальные файлы по логическим именам.

## 5. Правила чанкинга

1. **Core runtime** — лоадер, утилиты, реестр компонентов входят в соответствующий entry, чтобы запуск оставался детерминированным.
2. **Shared vendor** — зависимости, используемые в обоих бандлах (например, dayjs, axios), выносить в общий `vendor`-чанк ради кеша.
3. **Admin-only vendor** — CKEditor, CodeMirror, jQuery, jsTree/Fancytree, FileAPI и прочие админские библиотеки (Phase 4.1) остаются только в `admin` или его чанках; публичный бандл их не содержит.
4. **Динамические компоненты** — тяжёлые опциональные компоненты можно грузить через `import()`; Vite создаст асинхронные чанки в `/assets`, которые подхватит браузер.

## 6. Политика включения ресурсов

- **Входит в сборку**:
  - JS-модули всех компонентов, которые инициализирует лоадер.
  - Общие SCSS/CSS, импортированные из entry-файлов.
  - Изображения/шрифты, на которые есть `import`/`url()` в модульной цепочке.
- **Остаётся отдельными файлами**:
  - Легаси UMD/CDN-пакеты, которые по решениям Phase 4.1 должны грузиться отдельно (пока не выявлено, но правило зафиксировано).
  - Крупные статические медиа-папки, обслуживаемые напрямую (загрузки пользователей и т.п.).

## 7. Процесс сборки

- Запуск: `vite build --mode production` (или npm-скрипт, эквивалентный этой команде).
- Dev-сервер и HMR отключаются в prod-конфигурации.
- Билд генерирует `/assets/manifest.json` с маппингом логических имён на хешированные файлы.

## 8. Интеграция с PHP (debug = 0)

1. PHP читает `manifest.json` и подставляет актуальные имена бандлов в XSLT.
2. XSLT сохраняют свои `<script>`-позиции, но выводят хешированные пути с атрибутами по политике Phase 2.2 (`type="module"` или `defer`).
3. На страницу выводится один (публичный) или два (админ + публичный) основных бандла; дополнительные чанки подтягиваются динамически самим браузером.

## 9. Чек-лист деплоя

- [ ] Обновить `vite.config.js` (entry, outDir, hashing, сплит чанков).
- [ ] Описать команду сборки в README/операционных инструкциях.
- [ ] Настроить CI/CD на публикацию `/assets`.
- [ ] Добавить в PHP обработку `manifest.json` и защиту от отсутствия файла (фоллбек).
- [ ] Настроить кеширование: длинный TTL для хешированных файлов, короткий — для `manifest.json`.
