# Единый JS-лоадер (Фаза 3.2)

## 1. Назначение и область применения

Задача: описать поведение клиентского лоадера Energine, который одинаково работает в
`debug=1` (dev, набор отдельных файлов) и `debug=0` (prod, бандлы Vite). Лоадер отвечает за
инициализацию всех JS-компонентов, описанных декларативно через `data-energine-*`, обработку
тулбаров и диагностическое логирование. Спецификация не привязана к конкретной сборке, но
задаёт обязательные хуки и API ожидания от компонентных классов.

## 2. Жизненный цикл запуска

```text
[window DOMContentLoaded | document.readyState === 'interactive']
    ↓ если DOM уже готов — стартуем сразу; иначе подписываемся на событие
[loader.bootstrap()]
    ↓ собираем конфигурацию с DOM
[loader.initComponents()]
    ↓ создаём экземпляры, настраиваем тулбары
[loader.finalize()]
```

* Стартовать нужно после того, как DOM готов к обходу (не ранее `DOMContentLoaded`).
* Лоадер должен быть idempotent — повторный вызов не должен пересоздавать уже запущенные
  компоненты (например, если админская панель догружает контент Ajax’ом и повторно вызывает
  `loader.bootstrap()` для фрагмента).
* Для совместимости допускается явный вызов `window.EnergineLoader.run()` из стороннего кода;
  при отсутствии такого вызова лоадер сам запускается один раз.

## 3. Поиск целей и сбор данных

1. Опорный селектор — `[data-energine-js]` (работает как в dev, так и в prod).
2. Для каждой подходящей ноды:
   - считать строку `data-energine-js` и разбить по whitespace → список имён классов;
   - удостовериться, что элемент ещё не инициализирован данным классом (см. § 6 про пометки);
   - считать дополнительные атрибуты `data-energine-param-*` и собрать объект параметров
     (`{paramName: value}`), где имя получается из части после префикса;
   - при необходимости считать `data-energine-toolbar` (см. § 5) и `data-energine-translations`.
3. Сформировать очередь задач вида:

   ```js
   {
       element,
       className: 'GridManager',
       params: { template: 'default', pageSize: '20' },
       toolbarConfig: { /* может быть null */ },
       translationKey: 'component.gridManager'
   }
   ```

4. Порядок очереди — по обходу DOM сверху вниз (важно для зависимых компонентов, например,
   тулбар должен создаться раньше, чем вложенный грид).

## 4. Создание экземпляров компонентов

1. Лоадер получает конструктор из глобальной карты `window.Energine.componentRegistry`.
   - Регистрация классов выполняется скриптами компонентов: `Energine.register('GridManager', GridManagerClass)`.
   - В prod-бандле регистрируется тот же набор имён.
2. Требования к конструктору:
   - принимает минимум два аргумента `(element, params, context)`;
   - должен уметь работать без обязательных inline-данных (все параметры уже в `params`).
3. Лоадер создаёт экземпляр через `new` и сохраняет ссылку для повторного обращения
   (`element.__energineInstances.set(className, instance)`).
4. Если класс реализует интерфейс `initialize()` или `mount()`, лоадер вызывает метод после
   конструктора; отсутствие метода не считается ошибкой.
5. Ошибки инициализации логируются (см. § 6), но не должны прерывать запуск остальных задач.

## 5. Обработка тулбаров и вспомогательных зон

1. Тулбарные конфигурации описываются рядом с компонентом (см. Phase 1.1):
   - основной атрибут `data-energine-toolbar="toolbar-id"` либо `data-energine-toolbar-inline`;
   - описание кнопок располагается в DOM (например, `<div data-energine-toolbar-def="toolbar-id">…`).
2. Лоадер при сборе очереди ищет элемент конфигурации по ID/атрибуту и строит объект
   `toolbarConfig` (`{ slots: [...], actions: [...] }`).
3. После создания экземпляра компоненту передаётся конфигурация через `params.toolbar`
   (либо отдельный метод `attachToolbar(config)`, если класс его объявляет).
4. Если тулбар описан, но компонент не поддерживает тулбары (нет метода/флага) — лоадер пишет
   предупреждение в лог и продолжает работу.
5. Поддержать дополнительные зоны (например, переводчик):
   - `data-energine-translations` содержит ключ, по которому лоадер запрашивает тексты из
     глобального реестра переводов `Energine.translations[key]` и добавляет в `params.translations`.

## 6. Маркировка состояния и диагностика

* Каждый успешно инициализированный класс ставит маркер `data-energine-mounted="ClassName ClassName2"`
  или хранит Set в `element.__energineInstances`. Это предотвращает двойной запуск.
* Лоадер ведёт журнал (`console` в dev, на проде — через `Energine.logger`):
  - `info`: общее количество найденных компонентов, список классов;
  - `debug`: подробности по каждому экземпляру (параметры, время создания);
  - `warn`: отсутствующий класс, повторная инициализация, неподдерживаемый тулбар;
  - `error`: исключения из конструктора/initialize.
* Диагностический режим можно включить через `data-energine-debug="true"` на `<html>` или глобальную
  настройку; тогда лоадер дополнительно визуально помечает элементы (например, рамкой).

## 7. Поддержка динамических фрагментов

* Для Ajax-догрузок предоставляется API `EnergineLoader.scan(rootElement)` — выполняет ту же
  процедуру, но в пределах поддерева.
* Основной запуск (`bootstrap`) вызывает `scan(document)`.
* Компоненты, которые сами добавляют дочерние элементы, могут опционально уведомлять лоадер через
  `EnergineLoader.scan(newContainer)`.
* Повторная инициализация существующих элементов запрещена; лоадер пропускает те, у кого уже стоит
  маркер `data-energine-mounted`/`__energineInstances`.

## 8. Требования к совместимости

1. **Параметры из legacy-атрибутов.** На переходный период лоадер умеет читать значения из
   `data-param-*`/`data-component-*` (если встречает старую разметку) и логирует предупреждение.
   Приоритет: `data-energine-param-*` > legacy.
2. **ScriptLoader.addTask.** Старые страницы могут вызывать `Energine.addTask('ClassName', opts)` —
   лоадер реализует тонкую прослойку, которая конвертирует вызов в очередь компонентов, чтобы
   исключить критические падения до завершения миграции.
3. **Глобальные одноразовые скрипты.** Если компонент требует глобального объекта (например, CKEditor),
   предполагается, что библиотека уже загружена (Phase 2 обеспечивает поставку файлов). Лоадер не
   занимается загрузкой ресурсов, только проверяет их наличие при старте класса.
4. **Несколько классов на одном элементе.** Допустимы комбинации, например `data-energine-js="Toolbar GridManager"`.
   Лоадер создаёт экземпляры по очереди; каждый класс получает одинаковый набор параметров.
5. **Graceful degradation.** Если класс не найден или сломан, лоадер оставляет элемент в исходном
   виде и записывает ошибку, чтобы страница оставалась работоспособной.

## 9. Итоговый алгоритм (блок-схема)

```text
[Start]
  ↓
[DOM ready?] --no--> [wait DOMContentLoaded]
  ↓ yes
[scan(root=document)]
  ↓
[find elements with data-energine-js]
  ↓
[for each element]
  ↓
[for each class name]
  ↓
[already mounted?] --yes--> [skip]
  ↓ no
[collect params + toolbar + translations]
  ↓
[resolve constructor]
  ↓
[constructor exists?] --no--> [warn + continue]
  ↓ yes
[instantiate + post-init]
  ↓
[attach toolbar/translations]
  ↓
[mark mounted]
  ↓
[next class]
  ↓
[next element]
  ↓
[log summary]
  ↓
[Finish]
```

## 10. Результат

Спецификация покрывает единый клиентский лоадер: он стартует после загрузки DOM, собирает все
`data-energine-js`, создаёт экземпляры компонентов, привязывает тулбары и переводы, ведёт
диагностическое логирование и безопасно работает с динамическими фрагментами. Алгоритм одинаково
применим в dev (раздельные файлы) и prod (бандлы), обеспечивая совместимость со старым API во
время миграции.
